锁是一种用于实现线程同步的工具，它可以保证多个线程对共享资源的互斥访问，避免数据的不一致或错误。



但是，锁也会带来一些开销和问题，比如线程切换、阻塞、死锁等。为了提高锁的性能和效率，Java虚拟机对锁进行了一些优化机制，主要有以下几种：

偏向锁：	假设一个线程获得了锁，并且没有其他线程竞争该锁，则该线程再次请求该锁时，无需进行任何同步操作。	这种情况下，只需要在对象头中记录下获取过该锁的线程ID即可。

	即无线程竞争的时候,线程重入不需要同步操作

轻量级锁：假设一个线程获得了锁，且有其他线程竞争该锁，则该线程会将对象头中的部分信息复制到栈帧中，
	并将对象头中的标志位设置为轻量级锁状态。其他竞争线程会尝试使用CAS操作获取锁，
	如果成功则继续执行，如果失败则自旋等待。

	如果出现了锁竞争,那么就会将锁状态设置为轻量级锁.开始使用CAS获取锁,如果获取失败开启自旋锁

自旋锁：	假设一个线程没有获取到轻量级锁，则不会立即阻塞，而是进行一定次数/时间的循环检测锁是否被释放。
	这种方式避免了线程切换的开销，但如果自旋时间过长，也会浪费CPU资源。
	自旋锁是自适应的，自旋次数不是固定的，是由前一次在该锁上的自旋时间及锁的拥有者的状态来决定。

锁消除：	假设一个对象只在一个线程中用，不会被其他线程访问，则该对象上的同步操作是没有必要的。
	JVM可以通过逃逸分析技术判断一个对象是否会逃逸出方法的作用域，
	如果不会，则可以消除该对象上的所有同步操作。

锁粗化：	假设一个线程对同一个对象多次进行连续的加锁和解锁操作，
	则这些操作就可以合并为一次加锁和解锁操作。这样可以减少加锁和解锁的次数，提高性能。