# Linux收发网络包

## 网络模型

为解决各种设备在网络中兼容性问题，国际组织制定了开放式系统互联通信参考模型，也就是OSI网络模型

这个模型分7层，应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。

- 应用层： 给应用程序提供统一接口
- 表示层： 给数据转换为另一个系统兼容的格式
- 会话层： 建立、管理、终止表示层的通信会话
- 传输层： 端到端的数据传输
- 网络层： 数据的路由、转发、分片
- 数据链路层：数据的封帧和错差监测以及MAC寻址
- 物理层： 物理网络传输数据帧

OSI相当复杂，只是概念上的分层，实际常见的是四层网络模型，也就是TCP/IP模型，Linux通过这套模型实现网络协议栈

# 四层模型

- 应用层： 向用户提供一组应用程序,如HTTP/DNS/FTP
- 传输层： 端到端的通信，如TCP/UDP
- 网络层： 网络包的封装、分片、路由、转发。如IP、ICMP
- 网络接口层: 网络包在物理网络中的传输，如网络包的封帧、MAC寻址、差错检验、网卡传输网络帧

## Linux 网络协议栈

网络协议栈就是用来给数据进行封装的，传输层TCP给应用数据加TCP头进行收发数据，网络层给TCP加IP头进行远程定位，网络接口层给IP数据加帧头和帧尾保证内网设备间传输

这些头部的封装导致了数据包的大小增大，物理链路不能传输任意大小数据包，最大MTU（1500字节），如果超过就会进行分片传输

### 模型

- 应用程序进行系统调用，和Sockert套接字交互
- Socket会去分别适配对应的协议来收发传输，如TCP/UDP等

  - 再由IP模块来封装IP信息，确认定位
  - 由ARP模块来封装MAC保证物理设备间传输
- 最后由网卡驱动程序和硬件来进行实际传输

## Linux接收包

- 网卡是硬件，负责接收和发送网络包。
  - 网卡收到包的时候，通过DMA将网络包写入指定内存，然后告诉操作系统包到达
  - 告知方式
    - 触发中断： 收到网络包就触发一个中断告诉操作系统，但是网络包多的时候中断会非常多，影响cpu性能
    - Linux内核2.6版本引入NAPI机制，混合[中断和轮询]接受网络包，就是中断提醒数据接收服务程序，再用poll方式轮询数据
      - 具体操作： 写入对应内存后，就对cpu发起硬件中断，cpu调用注册的中断处理函数，中断函数会先暂时屏蔽中断，发起软中断，恢复屏蔽的中断
      - 软中断：内核中有现成负责软中断处理，当线程收到软中断后，会轮询数据
- 网络协议栈
  - 进入网络接口层，检查报文合法性，合法就找对网络包的上层协议类型，如IPv4或IPv6,再去掉帧头帧尾交给网络层
  - 网络层取出IP包，哦安定网络包是继续转发还是本机处理，确认是本机后判断包的是UDP协议还是TCP协议，去掉IP头，交给传输层
  - 传输层取出TCP头或UDP头，根据四元组（源IP，源端口，目标IP，目标端口）为标识，找到对应Socket，将数据放Socket接收缓冲区
  - 最后应用层调用Socket接口，将缓冲区的数据拷贝到应用层缓存区，唤醒用户进程

## Linux发送包

- 与上面流程相反，应用程序调用Socket发送包的接口（系统调用），内核会申请一个内存将发送的数据拷贝到内存中，并加入发送缓存区
- 网络协议栈按照TCP/IP从上到下逐层处理
- 如果用TCP发送数据，那就先拷贝一个新副本，因为发送完成后原来的内存会被释放，而TCP支持丢失重传，收到ack前不能删除。然后填充TCP头，交给网络层
- 网络层会选取路由（确认下一跳的IP），填充IP头，netfilter过滤，对超MTU大小包分片。交给网络接口层
- 网络接口层会通过ARP获取下一跳设备的MAC，然后填充帧头和帧尾，并发送到网卡的发送队列
- 以上工作完成后出发软中断告诉网卡驱动程序发送新数据，驱动程序读取队列中数据，将数据映射到网卡可访问的DMA区域，触发真实发送
- 发送完成后，因为数据没有清理，网卡触发硬终端释放内存
- 最后收到ack时，会释放原始数据内存
