bgsave 开始时,会fork主进程得到子进程,子进程共享主进程的内存数据.完成fork后读取内存数据并写入RDB文件



实现原理:
	Redis主进程要实现对内存的读写,要在内存中操作,
		但是在linux系统中,所有的进程都不能直接操作物理内存
		而是给每一个进程分配一个虚拟内存,操作系统会维护一个虚拟内存与物理内存间的映射关系表--页表
		
	当我们执行fork的时候,开启子进程,将页表拷贝给子进程
		子进程操作自己的虚拟内存自然可以映射到相同物理内存区域中
		实现无需拷贝内存数据,直接实现内存共享,并且速度很快

	然后子进程读取页表中数据(即主进程中数据),然后写入新的RDB文件,替换旧的数据,实现持久化

	
	问题:	当子进程向磁盘中写数据的时候,主进程修改数据怎么办?
	
				fork采用了copy-on-write技术:
					当主进程执行读操作的时候,访问共享内存
					当主进程执行写操作的时候,会拷贝一份数据共享数据,再执行写操作

					也就是说,fork时主进程每次写都要先复制一份共享内存,再对新共享内存修改,再将该内存
					修改映射为共享内存

					所以redis会预留一部分内存空间,避免RDB拷贝数据导致数据翻倍内存不足
	

总结:

	基本流程:	fork主进程得到一个子进程,共享内存空间
			子进程读取内存数据并写入新的RDB文件
			用新RDB文件替换旧的RDB文件

	RDB什么时候执行?	save 60 10000表示什么含义?
			默认服务停止时执行
			save 60 10000		#  代表着,如果60秒内,有10000次修改key请求,就触发RDB
	
	RDB缺点?
			RDB执行间隔长,两次RDB之间写入数据有丢失风险
			fork子进程,压缩,写出RDB文件都比较耗时


