Java Memory Model 	Java内存模型

	JMM定义了一套在多线程读写共享数据时,对数据的可见性,有序性,和原子性的规则和保障



原子性:
	保障方式:	synchronized(对象){}

			syn锁中为一个monitor区域
			monitor区域有 EntryList和Owner以及WaitSet

			owner是执行区域,记录持有锁的对象
			EntryList是排队等待区,存放等待获得锁的线程
			WaitSet是一个队列，存放调用了 wait() 方法而进入等待状态的线程。

	java中静态变量的自增自减不是原子操作

	静态变量是放在主内存中的,但是工作内存是独属于各个线程的私有内存,
		自增操作是要先从主内存获取静态变量的值,再自增,再将自增后的值写回主内存
		在多线程由于各个线程间工作内存的不可见

可见性:	
	当一个线程要不停的从主内存中读取同一个数据
	那么会触发缓冲优化,将该数据缓存在工作内存中,但是,如果主存中数据也在不停改变就会导致逻辑出错


	解决方法:	
		valatile关键字 :
			保证线程间的可见性,保证多个线程间,线程对valatile变量的修改对另一个线程可见
		
			但是,不能保证原子性,即往往只能保证多个线程的读操作,无法保证多个线程写操作


有序性:		程序中的操作执行时是否按照代码中的顺序进行或是否按照程序员的预期进行。

		有序性是JMM的特性，保证不同线程对共享变量的操作在一定程度上具有一致性和可预测性。
	

	但由于编译器、处理器和内存等因素的影响，程序中的操作在执行时可能发生重排序，
	即改变操作的执行顺序，从而提高程序的性能。重排序分为以下三种类型：

	编译器重排序：编译器在编译过程中，为优化程序，可能会改变指令的顺序，但保证程序的语义不变。

	处理器重排序：处理器在执行过程中，为利用流水线、乱序执行等技术，可能会改变指令的顺序，
			但保证程序在单个处理器内部的语义不变。

	内存系统重排序：内存系统在读写过程中，为提高吞吐量和缓存命中率，可能会改变数据的顺序，
			但保证程序在单个内存系统内部的语义不变。

	重排序虽可以提高程序的性能，但也会带来一些问题，如导致多线程之间的数据不一致、逻辑错误等。
	





	为解决这些有序性问题，JMM 提供了一些规则和机制来约束和控制重排序来保证有序性。
	这些规则和机制包括以下几种：

	程序顺序规则：	一种基本的规则，指定了一个线程内部的操作必须按照代码中的顺序执行。

	监视器锁规则：	一种用于实现同步控制的规则，
			指定了对一个锁的解锁操作必须在后续对该锁的加锁操作之前执行。

 ***  volatile变量规则：	一种用于实现可见性和有序性的规则，
			指定了对一个 volatile 变量的写操作必须在后续对该变量的读操作前执行，
			且禁止对 volatile 变量进行重排序。

	线程启动规则：	一种用于实现线程间通信的规则，
			指定了主线程对一个线程对象的 start() 方法的调用必须在该线程执行之前执行。

	线程终止规则：	一种用于实现线程间通信的规则，
			指定了主线程检测到一个线程对象已经终止，
				必须能够看到该线程执行期间对共享变量所做的所有修改。

	线程中断规则：	一种用于实现线程间通信的规则，
			指定了对一个线程对象的 interrupt() 方法的调用必须被中断线程检测到中断请求			之前执行。

	对象终结规则：	一种用于实现对象回收和清理的规则，
			指定了一个对象的构造函数必须在该对象被垃圾回收器回收之前执行完毕
			且如果该对象覆盖了 finalize() 方法，
			则该方法也必须在该对象被垃圾回收器回收之前执行完毕。

	传递性：		一种用于推导有序性的规则，
		指定了操作 A 在操作 B 之前执行，操作 B 在操作 C 之前执行，那么操作 A 在操作 C 前执行



		




