CAS:	Compare and Swap	采用乐观锁思想

		先读取共享变量,在修改值前将该值与原值比较,
			如果不同就不修改,再次读取,重新获取锁
			如果相同就修改退出循环,成功获取锁

		为保证变量的可见性,要用valatile修饰.结合CAS和calatile可以实现无锁并发

		适用于线程低竞争的时候,效率会提高
		但是线程高竞争会导致修改不停重试导致效率下降

		底层在Unsafe类中有CAS的实现,反射获取,调用即可

乐观锁的常见实现方式:
	版本号机制：
		在数据表中增加一个版本号字段，每次更新数据时，版本号加一，并检查当前版本号是否和
		数据库/Redis中的版本号一致。
		如果一致，更新成功；
		如果不一致，更新失败，需要重试或放弃操作。

	CAS机制：
		使用一个变量记录数据的当前状态，每次更新数据时，比较当前状态和期望状态是否相同。
		如果相同，则用新状态更新数据和当前状态；
		如果不同，更新失败，需要重试或放弃操作。


			
java中乐观锁与悲观锁:
	乐观锁:CAS		并发情况不怕变量被修改,可以不断重试		
	悲观锁:synchronized	避免其他线程修改变量

	
原子操作类:	(jdk5)juc提供了原子操作类,提供线程安全的操作,
		如:	AtomicInteger,AtomicBoolean
		












		
	










