JMM（Java Memory Model，Java内存模型）

	一种抽象的概念，并不真实存在，描述了一组规则或者规范，
	用于屏蔽掉各种硬件和操作系统的内存访问差异，
	以实现让Java程序在各种平台下都能达到一致的并发效果。

JMM主要定义了以下几个方面：
	主内存和工作内存：
		主内存是所有线程共享的内存区域，用于存储共享变量；
		工作内存是每个线程私有的内存区域，用于存储线程使用的变量的副本。
		线程对共享变量的操作都必须在工作内存中进行，然后同步到主内存中。
	
	内存间交互操作：
		JMM定义了八种原子操作来完成主内存和工作内存之间的数据交互，
			分别是lock（锁定）、unlock（解锁）、read（读取）、load（载入）、
			use（使用）、assign（赋值）、store（存储）和write（写入）。


内存模型与硬件架构的关系：
	JMM与硬件架构不完全一致，硬件架构只有寄存器、缓存行和主内存的概念，没有区分线程栈和堆。
	JMM与硬件架构是一种相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。


内存模型与Java语言的关系：
	JMM为Java语言提供了一些关键字和语法保证多线程环境下的原子性、可见性和有序性。
	如volatile、synchronized、final、happens-before等。

JMM存在的必要性:
	为了解决多线程环境下的变量同步问题，避免使用锁机制造成的性能损耗。

	由于不同的硬件和操作系统可能会对内存访问进行优化，导致数据在多个线程间不一致或者乱序。
	为了保证Java程序在任何平台上都能得到相同结果，需要一个统一的规范约束内存访问行为。
	JMM就是这样一个规范，定义了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，
	以及在必须时如何同步地访问共享变量。








