不断创建和销毁线程非常销毁性能,浪费资源

线程池

	创建一个线程池,空的
	提交任务的时候,线程池会创建新线程对象,任务执行完毕,线程归还给线程池,下次再提交任务,不会再创		建线程,而是复用已有线程
	如果提交任务时,线程池没有空闲线程,也无法创建新线程,任务就会排队


代码实现
	创建线程池
		构造方法static静态
		ExecutorService newCachedThreadPool()	
			(最多是int最大值)					没有上限的线程池
			
		ExecutorService newFixedThreadPool(int nThreads)
									有上限的线程池
		ExecutorService newCachedThreadPool(): 				
				一个可缓存线程池，灵活的创建/回收线程，若无可回收，则新建线程。

		ExecutorService newSingleThreadExecutor(): 			
				初始化一个具有一个线程的线程池
		
		ScheduledExecutorService newSingleThreadScheduledExecutor(): 
				一个具有一个线程的线程池，支持定时及周期性任务执行
									

		线程池中线程方法
			Future<?> submit(Runnable task)：	提交任务
			void shutdown()：			关闭线程池
				

	提交任务

	任务执行完毕,关闭线程池(实际中,线程池一般不关)



自定义线程池
	ThreadPoolExector()
	自定义线程池的构造方法,七个参数解释
	corePoolSize：   		核心线程的最大值，不能小于0
	maximumPoolSize：	最大线程数，不能小于等于0，maximumPoolSize>= corePoolSize
	keepAliveTime：  		空闲线程最大存活时间,不能小于0
	unit：           		时间单位
	workQueue：      		任务队列，不能为null
	threadFactory：  		创建线程工厂,不能为null      
	handler：        		任务的拒绝策略,不能为null    
			一般用的是
			Executors.defaultThreadFactory()	底层就是new个Thread,加设置
	任务的拒绝策略(ThreadPoolExector中的静态内部类)
			AbortPolicy		丢弃任务并抛出RejectedExecution异常
			DiscardPolicy		丢弃任务但是不抛出异常
			DiscardOldestPolicy	抛弃队列中等待最久的任务,把当前任务加入队列
			CallerRunsPolicy	调用任务的run()方法绕过线程池直接执行




	判断线程池大小多少合适?
		cpu密集运算的项目:	最大并行数+1
		IO密集型运算的项目:	
			最大并行数*期望cpu利用率*总时间(cpu计算时间+等待时间)/cpu计算时间
		

		最大并行数:		java虚拟机可用的处理器数目,其实就是电脑的线程数,
					如四核八线程,那最大并行数就是8
					
			代码获取方式:	int i = Runtime.getRuntime().availableProcessors();
			
		

