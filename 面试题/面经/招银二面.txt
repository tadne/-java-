MybatisPlus和Mybatis的区别
	MP可以简化开发，提供了很多api和工具
	内置增强功能，比如代码生成器、分页插件、条件构造器等
	集成方便，提供一些列stater，配置简单
	提供大量crud方法

	但是MP相比于Mybatis，不够灵活，在遇到复杂SQL的时候，Mybatis有动态SQL进行操作，但MP只能使用封装	好的条件构造器，这种条件构造器会增加SQl的复杂度和维护成本

JDBC的执行流程
	加载驱动：			数据库交互前，先加载驱动，可以使用Class.forName()加载数据库驱动
	建立数据库连接：		使用JDBC中的DriverManager.getConnection() 方法，要有密码账号等信息
	创建statement：		也就是写sql
	执行SQL：			调用statement的execute() 方法来执行 SQL 语句。
	处理结果集：			对返回的ResultSet类型的数据，采用ResultSet的next方法遍历
	关闭连接和释放资源：	

Spring项目中事务实现：
	声明式事务：	基于注解@Transactional，通过在方法上声明，然后在配置文件中启动事务管理器，然后					spring会自动为其添加事务管理
	xml事务：	可以再xml中配置事务管理器和事务通知器，并在配置文件中定义切点和事务通知器的关系
	
	声明式事务的实现：
		AOP动态代理：Spring用AOP拦截被标记的方法，在方法执行前后添加事务管理逻辑。
		事务管理器：	事务管理器管理事务的开始，提交，回滚，关闭
		事务通知器：	AOP中事务管理逻辑被封装在事务通知器中，@Transactional注解被解析为事务通知器
		事务属性解析：@Transactional中属性会被解析成事务相关配置，便于在事务管理器中正确设置事务行为
		事务拦截：	被@Transactional标记的方法被调用时，AOP就拦截方法调用
					根据配置决定开启新事务还是加入已经存在的事务。
		事务管理：	根据方法执行情况，事务管理器来决定是否回滚或提交

	定义注解的步骤：	
		创建注解类：	
		定义注解属性或者标签：
		针对标签写对应的命名空间处理器和解析器
		
		执行流程：
			加载配置文件，获取对应的配置信息
			通过命名空间处理器进行处理
			命名空间通过寻找对应的标签解析器进行解析
			标签解析器使用registerBeanDefinition方法将对应标签注册成对应BeanDefinition
			加入BeanDefinitionMap中参与Bean的生命周期

SpringBoot怎么实现定时任务
	可以使用@Scheduled注解
	先添加对应依赖
	创建定时任务类，在类中定义对应的定时执行方法
	在定时方法上使用@Scheduled注解
	在启动类上添加@EnableScheduling注解开启定时任务功能

	项目中怎么实现定时任务的
		使用xxl-job实现定时任务，
			配置依赖，数据源、
			准备数据库存对应任务的相关信息、执行日志等
			创建一个MyHandle组件，使用@XxlJob("myHandle")注解标记myHandle(String param)方法
			在方法中写对应的任务执行逻辑
			启动项目，访问XxlJob的地址，然后在页面图形化完成定时操作
			
	
	
多个数据包传到Controller层之前怎么进行检验拦截，除了拦截器外，还有哪些实现方式
	使用SpringMVC的过滤器：	
	AOP定义切面进行拦截：
	自定义注解：	在controller上标注解，然后自定义切面进行处理拦截
	


用户登录完成后，服务器需要进行以下操作来确认用户已经成功登录并且可以执行后续的操作：
	一般是采用ThreadLocal或者Session或者Cookie储存会话信息
	用会话信息做对应的权限认证

如果有多台服务器，用户登录了，服务器怎么知道是同一个用户，负载均衡怎么实现？
	登录信息共享的实现方式：
		数据库或者缓存记录登录会话信息	
		用负载均衡器启动粘性会话功能，确保用户请求定向到同一个服务器
		统一身份验证，也就是token，token在所有服务器通用
		分布式会话管理，将会话信息存在多个服务器实现跨服务器会话分享

	负载均衡实现：
		轮询、基于权重、基于最小连接数、基于IP散列实现会话粘性
		
Spring循环依赖怎么发生的？
	循环依赖是因为Bean的构建需要其他Bean，如果A创建以来B，B的创建依赖C，C的创建依赖A
		一般有构造器注入循环、字段注入循环、方法注入循环
	这样就出现了循环依赖，Spring的解决方式是采用了三级缓冲
		一级缓存：	存储正常创建的Bean的工厂对象
		二级缓存：	存储创建完成没有初始化的对象
		三级缓存：	单例对象的缓存
		
海量数据分库分表，用线程池查询，可以通过控制并发量优化查询性能。使用CountDownLatch
	创建CountDownLatch对象，初始计数设置为分片数目
	在每个查询任务结束时，计数-1
	主线程调用await方法等待查询任务完成
	所有查询任务完成主线程就恢复

​假设有一个user表，写一条语句把其中年龄第三大并且性别为女的用户记录查询出来
	select * from user where gender = '女' order by age desc limit 1 offset 2;


DDD框架的依赖倒置
	提出一种方式减少高层模块对低层模块的以依赖，让二者都依赖于抽象接口。
	
DDD四层架构
	领域层、应用层、基础设施层、接口层
	

	核心概念：
		高层（api层、领域层）不依赖于（数据访问层、基础设施层）
	

为什么会有最左前缀法则
	数据库引擎执行查询时，通常使用 B+树等数据结构组织索引。这些数据结构有特定的性质，如在B-树中，数据按排序顺序存储，每个节点都含一定数量的键和指向子节点的指针。查询时，数据库引擎从根节点开始向下遍历树形结构，根据查询条件找到匹配的叶子节点或者数据页，从而定位到具体的数据行。
	由于索引的数据结构特性，数据库引擎在执行查询时是从索引的最左侧开始匹配的。这是因为索引中的数据是按照排序顺序存储的，只有在最左侧的字段确定的情况下，才能通过索引快速定位到匹配的数据行。如果只通过索引的右侧部分进行扫描，那么数据库引擎无法利用索引的排序性质，无法快速定位到匹配的数据行，从而无法实现有效的索引扫描和查询优化。
	
