虚拟机栈
	
	栈:		先进后出

	栈帧:	每个方法运行时需要的内存:	参数,局部变量,返回地址

		也就是包含了  局部变量表、操作数栈、动态链接、方法出口等信息
		(栈帧就是虚拟机栈中的一个元素,先进后出)
		(类似java方法栈中的方法)

		动态链接:
			指Java文件被编译到字节码文件中时，变量和方法引用都作为符号引用存在class文件的常量池，
			程序运行时将其加载进方法区的运行时常量池中。

			当方法被调用时，虚拟机会将方法在常量池中的符号引用转换为直接引用，并存在线程虚拟机栈中。
			动态链接的作用是将符号引用转换为调用方法的直接引用，从而实现方法调用.

		方法出口:
			指方法执行完毕后，返回到调用该方法的位置的指令地址。

			在jvm中，方法出口是由返回指令 (return) 指定的。
				当方法被调用时，jvm会将调用方法的指令地址压入线程虚拟机栈中，当方法执行完毕后，
				Jjvm会从虚拟机栈中弹出该指令地址，并跳转到该地址继续执行。
				因此，方法出口是指返回到调用该方法的位置的指令地址。

		局部变量表:
			一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。
			局部变量表的容量以变量槽为最小单位，jvm规范没有定义一个槽所应该占用内存空间的大小，
			但规定了一个槽应可存放一个32位以内的数据类型。在Java程序编译为Class文件时,
			在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。

		操作数栈:
			一个后入先出栈，用于存储操作数和返回值。
			操作数栈的元素可以是任意Java类型，32位数据类型占一个栈容量，64位数据类型占2个栈容量。
			方法执行过程中，jvm会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，
			并随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者。


		
	活动栈帧:每个线程只能有一个活动栈帧,对应正在执行的方法

	虚拟机栈:	Java虚拟机中的一种数据结构
			线程运行时需要的内存空间,不同的线程不同,用于存储每个线程执行的方法的信息
			栈由多个栈帧组成,每个栈帧对应一个方法的调用和执行

	Java Virtual Machine Stakes(Java虚拟机栈)
		每个线程运行时所需要的内存,称为虚拟机栈
		每个栈由多个栈帧组成,对应着每次方法调用时所占用的内存
		每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法,在栈的顶部
		虚拟机栈是线程私有的，它与线程的生命周期同步，不会存在垃圾回收问题



	问题:	
		垃圾回收是否涉及栈内存?
			栈内存是方法调用留下的栈帧内存,每次方法调用结束后,会被弹出栈,自动被回收
			不需要垃圾回收处理

		栈内存分配越大越好吗?
			Linux/mac/Orache	默认栈内存是1m:1024kb
			栈内存大了,只是可以支持更多次的递归方法调用,不会速度变快
			而且栈内存越大,线程总数量越少

		方法内的局部变量是否是线程安全?
			看一个变量是否线程安全,就是看多个线程对这个变量是共享的还是私有的
			如果是局部的变量,那就会存在线程自己的栈帧中,互不干扰
			如果改成static修饰,共享变量,那就可能会出现线程安全问题
		

		栈内存溢出 stackOverflowError
			原因:	1栈帧过多导致栈内存溢出
				例:	方法递归调用时,没有设置合适的结束条件
				例:	在转json字符串的时候,两个对象互相给参数,造成溢出

					2栈帧过大导致栈内存溢出
				
			解决:	可以在设置中设置栈内存大小,如:	-Xss100k
			

	线程诊断	
		案例1:	cpu占用过高	
			例:	while(true){}

		定位:	用top命令定位哪个线程cpu占用过高
			用ps H -eo pid,tid,%cpu|grep 进程id
				(用ps命令进一步定位是哪个线程cpu占用高)
			jstack 进程id
				(根据线程id找到有问题的线程,进一步定位问题代码行号)

			用top命令查询进程在cpu中占用过高,查看pid
			ps H pid , tid , %cpu | grep	命令查看线程占用
			还可以用     jstack pid来查看进程里线程信息
			

		案例2:	程序运行很长时间
			例:	死锁,

		定位:	用同样方式定位,其中jstack可以看到问题原因,位置
			



			
		