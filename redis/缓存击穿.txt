缓存击穿:
	
		缓存击穿问题也叫热点key问题,就是应该高并发访问并且缓存重建业务比较复杂的key突然失效
		无数请求就达到数据库带来压力


		解决方案:		一致性和可用性的抉择

	互斥锁:
		线程1:	查询缓存,没有		获取锁成功	查询数据库重建缓存数据		写入缓存	  释放锁
		线程2:			查询没有  	 获取锁失败			CAS自旋访问缓存			缓存命中
		
	逻辑过期:
			
		线程1:	查询缓存,超过逻辑时间过期	获取互斥锁成功	开启新线程2修改数据库    返回过期数据
		新线程2:														查询数据库,重建逻辑,释放锁
		线程3:		查询缓存,超过逻辑过期		获取互斥锁失败	返回过期数据
		

				优点												缺点

	互斥锁:		没有额外的内存消耗,保证一致性,实现简单			线程要等待,性能受影响,有死锁风险
	
	逻辑过期:		线程不用等待,性能好							不保证一致性,有额外内存消耗,实现复杂



	互斥锁实现:

		开始==>从redis中查缓存==>判断缓存是否存在

			==>存在就返回数据==>结束	
			==>不存在就尝试获取锁==>判断是否获取锁

					==>获取锁成功就查询数据库==>写入缓存==>释放锁==>返回数据==>结束
					==>获取锁失败就休眠一段时间==>再次查询缓存


	逻辑过期实现:
		开始==>从redis中查缓存==>判断缓存是否存在

			==>不存在就返回空==>结束
			==>存在就判断缓存是否过期

				==>没有过期就返回数据==>结束
				==>过期就尝试获取互斥锁==>判断是否获得锁
			
					==>获取锁失败==>返回过期数据==>结束
					==>获取锁成功==>开启独立线程执行缓存重建==>返回过期数据==>结束

						独立线程==>查询数据库==>写入redis并设置过期时间==>释放锁
	




		