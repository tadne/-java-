线程的创建与启动
	
	在java中,创建一个线程就是创建一个Thread类的对象

	Thread有两个常用的构造方法

		Thread()
		Thread(Runnable)

	创建线程的三种方式:
		第一种
			1.创建一个继承于Thread类的子类
			2.重写Thread类的run() --> 将此线程执行的操作声明在run()中
			3.创建Thread类的子类的对象
			4.通过此对象调用start()执行线程
	
		第二种
			1.创建一个实现了Runnable接口的类
			2.实现类去实现Runnable中的抽象方法：run()方法
			3.创建实现类的对象
			4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象	
			5.通过Thread类的对象调用start()
				① 启动线程
				② 调用当前线程的run()–>调用了Runnable类型的target的run()
	
		第三种		
			1.创建一个实现Callable的实现类
			2.实现call方法，将此线程需要执行的操作声明在call()中
			3.创建Callable接口实现类的对象
			4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，
				创建FutureTask的对象
			5.将FutureTask的对象作为参数传递到Thread类的构造器中，
				创建Thread对象，并调用start()
			6.获取Callable中call方法的返回值

	多线程运行结果与代码执行顺序无关
		start方法是用来启动线程的,启动线程的实质就是请求jvm运行相应的线程,
			这个线程具体的执行时间是由线程调度器(Scheduler)决定

		所以:
			所以,start方法调用结束并不意味着子线程开始运行
			新开启的线程会执行run()方法
			如果开启了多个线程,start()调用的顺序并不一定就是线程启动的顺序

			具体的执行都是由线程调度器决定
			即多线程运行结果与代码执行顺序无关
	


	线程的第一种方式和第二种方式
		开发中优先使用第二种创建方式
		原因:	实现的方式没有类的单继承性的局限性,所有可以让代码有更好的扩展性
			实现的方式更适合来处理多个线程有共享数据的情况

		共同点:	两种方式都要重写run方法,将线程要执行的逻辑声明在run中


	第三种方式的好处
		call方法可以有返回值,也就是可以在主线程中获取子线程执行的结果
		call方法可以抛出异常,被捕获异常信息
		callable接口支持泛型

		
		
		




		