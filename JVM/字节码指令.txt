字节码指令
	

javap工具	

	javap -v HelloWorld.class  反编译命令

	当然,这个命令要先找的class文件

	
类加载
	
	原始java代码

	编译,得到字节码文件
	
	常量池载入运行时常量池
		但是一些 -128~127 不存在常量池中,而是和方法的字节码指令在一起
		java底层缓存了-128~127的整数

	方法的字节码指令载入方法区中

	main线程开始运行,分配栈帧内存
		栈帧内存:	局部变量表,操作数栈


案例:	分析a++
	psvm{	
		int a=10;
		int b=a++ + ++a + a--;}

	a++和++a的区别是执行iload还是先执行iinc,iinc命令是自增命令,iload是计算

	加载a=10到操作数栈
	改变局部变量表a=11
	改变局部变量表a=12
	相加10+12=22
	相加22+12=34
	改变局部变量表a=11
	b=34
	
案例:
	int x=10;
	while(true){
		x=x++;	
	}
			先加载x=10到操作数栈
			修改局部变量表x=11;
			再讲操作数栈中的10赋值给x



	static int a=10;
	static{a=20;}
	static{a=30;}
			静态变量的赋值会被java收集为一个新的构造方法,原始构造方法被放在最后	
			<cinit>()V	收集static代码块和变量赋值的代码,初始化
		


	{b=20;}
	private int b=10;
	构造方法(int b){this.b=b;}
			局部变量同样会被收集为一个新的构造方法,原始构造方法会被放在最后
			<init>()V
	
	也就是说,会先执行直接赋值代码,后执行构造方法的代码
		
	例:
	    test(int b){
	        this.b=10;//后执行
	    }
    	int b=20;//先执行
    	public static void main(String[] args) {
    	    test t=new test(1);
    	    System.out.println(t.b);//10
    	}

方法调用
	构造方法和私有方法和静态方法是唯一确定的,是直接绑定的
	但是public普通方法是动态绑定的

	对于静态方法的调用,是不需要对象调用的,在加载到操作数栈中时,会直接pop
		

多态的原理
	执行invokevirtual指令调用方法时
		
	先通过栈帧中对象引用找到对象
	分析对象头,找到对象实际的class指令
	class结构中有虚方法表vtable,它在类加载的链接阶段就已经根据方法的重写规则生成好了
	查表得到方法的具体地址
	执行方法的字节码


锁synchronized

	