# TCP连接断开

## TCP四次挥手过程

TCP断开连接使用四次挥手方式

双方都可以主动断开连接，端口连接后主机中的资源将被释放

![alt text](format,png-20230309230614791.webp)

- 客户端打算关闭连接，准备报文
  - 将FIN置于1
  - 客户端进入FIN_WAIT_1状态
- 服务端收到FIN，准备报文
  - 将ACK置于1
  - 服务端进入CLOSE_WAIT状态
- 客户端收到ACK
  - 客户端进入FIN_WAIT_2状态
- 服务端处理完数据后，准备报文
  - 将FIN置于1
  - 服务端进入LAST_ACK状态
- 客户端收到FIN，准备报文
  - 将ACK置于1
  - 客户端进入TIME_WAIT状态
- 客户端经过2MSL时间后，自动关闭
- 服务端经过2MSL时间后，自动关闭

要注意的是，这里服务端连着发了两个报文，这是因为服务端收到要断开连接的消息后，要先处理完数据才能断开

## 为什么要挥手四次？
回顾四次挥手
- 关闭连接时，客户端发送FIN，只表示客户端不再发数据了，但还能收数据
- 服务端收到FIN时，先回ACK，但是服务端可能还有数据要处理和发送，等服务端不再发数据时，才发送FIN给客户端

以上过程可以知道，服务端要等待数据发生和处理，所以服务端ACK和FIN会分开发送，因此要四次挥手。

特定情况下，四次挥手可以变成三次！

## 第一次挥手丢失
客户端调用close函数，向服务端发FIN，客户端进入FIN_WAIT_1

如果第一次挥手丢失，客户端收不到ACK就会超时重传，重传超过默认5次后直接进入close

## 第二次挥手丢失
服务端收到客户端FIN后，回复ACk，服务端进入CLOSE_WAIT状态

ACK报文不会重传，所以客户端收不到ACK，客户端超时重传。重传超过默认5次后直接进入close

如果客户端收到第二次挥手，会等服务端发送FIN，但是对于close函数关闭的连接，无法再发送和接受消息，所以FIN_WAIT_2状态不能持续太久，默认值为60秒。意味着对于close连接，如果60秒没收到FIN，客户端连接直接关闭

但是shutdown函数可以只关闭乙方的发送连接，而不关闭接收。

## 第三次握手丢失
服务端收到客户端的FIN后，内核自动回复ACK，同时连接进入CLOSE_WAIT，表示等待应用进程调用close函数关闭连接。这时内核是没有权利替代进程关闭连接的，必须要进程主动调用close函数触发服务端发送FIN

服务端处于CLOSE_WAIT状态，调用close函数，内核就会发出FIN，同时进入LAST_ACK。等待客户端ACK确认连接关闭。

如果ACK丢失，服务端会超时重传

## 第四次握手丢失
客户端收到服务端第三次挥手FIN后，回复ACK。此时客户端进入TIME_WAIT

Linux中，TIME_WAIT持续2MSL。

如果服务端没有收到ACK，服务端会触发超时重传。如果在2MSL中再次收到FIN，就重发ACK和重置定时器

## 为什么TIME_WAIT等待2MSL
MSL是报文最大生存时间，超过这个时间报文就会被丢弃。因为TCP报文是基于IP协议的，IP头中有TTL字段，是IP数据包可以经过最大的路由数。如果这个值为0则数据丢弃，同时发送ICMP给源主机

MSL和TTL的区别：MSL单位是时间，TTL是经过路由数。**MSL应该大于等于TTL消耗为0的时间**。

**TTL值一般是64，Linux将MSL置为30秒，Linux认为数据报文经过64个路由器时间不会超过30秒，超过就说明报文丢失**，2MSL是指一来一回的双倍时间


## 为什么需要TIME_WAIT状态

主动关闭连接的一方才会有TIME_WAIT状态

原因：
#### 防止历史连接数据被相同四元组连接接收
- 序列号是TCP中标识数据流的一个字节，保证消息的顺序性和可靠性，为每个字节赋予编号。序列号是一个32位无符号数，在到达4G后循环到0
- 初始序列号，TCP连接建立后，客户端服务端会各生成一个序列号保证连接有不同序列号。初始化序列号可以被视为32位计数器，4微秒+1，
- **序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。**

如果TIME_WAIT没有等待时间或时间过短会怎么样？
- 服务端关闭连接前发送SEQ=301，网络延迟
- 服务端重新打开新连接，这时前面的SEQ=301到达客户端，该数据的序列号刚好在客户端接受窗口中，因此客户端会接受这个数据，但这个数据是上一个链接的，导致数据错乱

为了防止历史连接，TCP设计了TIME_WAIT时间持续2MSL。**这个时长足够让两个方向数据包被丢弃**

#### 保证被动关闭连接的一方能被正确关闭

RFC793中指出：TIME-WAIT 作用是**等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。**

如果客户端最后的ACK丢失了，那么服务端会重发FIN。加上客户端没有TIME_WAIT，那就在ACK后直接CLOSE，这时收到服务端重传的FIN会返回RST。为了避免这种情况，客户端必须等待足够长时间保证服务器收到ack。
 
## TIME_WAIT过多的危害
- 占用系统资源，比如文件描述符、内存资源、CPU资源、线程资源

