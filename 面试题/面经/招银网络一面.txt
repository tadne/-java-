四种访问修饰符
	public：		任意包下类
	protected：	非同一包下的继承类
	default：		同一包下的类
	private：		本类

四种非访问修饰符：
	static：			成员变量、方法属于类而不是实例
	final：			表示最终变量、方法，不可修改
	abstract：		表示类或方法不能被实例化
	Synchronized：	确保同一时间只有一个线程可以访问当前类或方法
	volatile：		保证多线程下的可见性，

重载和重写：
	重载：	同一个类中相同名称参数不同的方法
	重写：	子类或实现类重新定义具体实现的方法

arraylist和linkedlist的区别
	arraylist是基于数组实现，支持索引访问，随机访问性能好，对增删效果不好
	linkedlist是基于链表实现，不支持索引访问，随机访问性能不稳定，对增删效果好

多态理解
	多态主要是一个东西的多种形态，有继承多态和接口多态，主要就是子类或者实现类可以作为参数构建父类，当调用时，使用的是父类方法，但是实际实现是在子类中

	项目中的应用：	
		多态的应用就比较普遍了，比如创建List集合的时候，再比如三层架构调用service层接口的时候，
		好处主要是
			使用比较灵活（父类操作子类适应不同类型），
			方便扩展（使用时继承父类即可），
			可维护（父类引用子类对象，修改时只需要修改父类的引用即可），
			代码复用（在父类下定义子类的实现）	
			
异常有哪些？捕获机制
	异常主要有:	NullPointException，BeanCreatException,ArrayIndexOutOfBoundsException,
				NumberFormatException,NoSuchElementException等等

	try{}catch{}finally{}：
		try中包含可能抛出异常的代码段
		catch中包含出现异常后的处理代码，一般包括出来异常信息，返回特定业务信息等
		finally中包含一定会执行的代码，一般包括释放资源等操作

其他集合类：
	Set集合、Map集合、Queue: HashSet、treeSet、LinkedHashMap、PriorityQueue

	
TCP三次握手：
	客户端 SYN : 发起连接
	服务端 SYN+ACK : 确认连接并发起连接
	客户端 ACK ：确认连接

	为什么要三次握手？
		三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。

			如果客户端发送SYN后，客户端出了问题，此时消息被网络阻塞了。那么当客户端重启后，再次建立		连接，这个时候服务端又收到之前的消息，就会导致混乱。
			
		三次握手通过，客户端的确认号、服务端的确认号来确认连接的唯一性。	

TCP序列号、确认号：
	
	序列号	标识TCP数据流中数据段的顺序和位置
			也用于流量控制和拥塞控制，帮助调整发送速率，防止丢包和网络阻塞
	
	确认号	告知对方确认已经成功接收数据段，并且保证连接唯一性
			实现tcp可靠性，根据确认号进行超时重传
			

键入网址到网页显示流程：
		浏览器解析url
		DNS根据域名解析出 IP地址
		协议栈负责发送传输数据
			同一主机下：TCP包头，封装源端口和目标端口，加上窗口大小、确认号之类的
			主机与路由器：IP包头，封装源IP和目标IP，
			不同主机间：mac包头，封装源mac和目标mac，其中目标mac可变
		网卡复杂将数字信息转换为电信号
		交换机根据mac地址表查mac地址，然后将信号发到路由器
		路由器接收发送来的网络包，然后通过路由表转发目标网络的路由器
		目标网络路由器转发给目标主机

		IP是全局范围内唯一标识，mac地址是局域网内唯一标识
		
树的遍历
	四种： 前序、中序、后序、层序，前中后序都是按照根节点位置来命名，层序遍历就是按照从上到下顺序逐层遍历。

HTTP和TCP长连接的区别
	HTTP是应用层协议，控制在客户端和服务器之间传输数据，
	TCP是传输层协议，负责提供可靠的数据传输服务。
		TCP长连接是在TCP层的概念，允许在一段时间内保持TCP连接的打开状态，
		HTTP则可以利用TCP长连接来提高性能，减少连接建立和断开的开销。
	
	而且HTTP现在版本很多，HTTP1、2、3，HTTP1和2使用的是TCP协议，并且
		HTTP1采用长连接优化
		HTTP2采用的是stream并发传输，多路复用
		HTTP3直接采用了uniqc协议，使用udp实现了。


自我介绍。。。

印象最深、帮助最大的项目。。。

接口和抽象类的区别：
	接口是interface关键字
	抽象类是abstract实现，	
	定义：
		接口是一种抽象类型，定义了一组方法签名但没具体实现，接口只含方法的声明，没有方法的实现代码。
		抽象类是一种可以包含抽象方法的类，可包含具体方法的实现，也可包含抽象方法的声明。
			抽象类可以有构造函数和成员变量。

	抽象类主要是通过继承机制实现

	接口提供一种定义方法的契约，抽象类提供将方法的共同实现提取到一个基类中的机制。
	通常，
		如果多个类需要共享某些行为但没有共同的实现，可使用接口；	
		如果多个类有共同的实现或者需要包含一些状态和行为，可以使用抽象类。

	例子：
		集合中，顶层接口Collection，子接口List、Set、Map等
		spring中，AbstractApplicationContext 是一个抽象类，
			提供通用的上下文功能、启动关闭上下文的模版方法，提供扩展、管理生命周期

	但是感觉抽象类的使用特别少，没怎么见过


HashMap底层实现原理，为什么线程不安全，ConcurrentHashMap怎么实现线程安全？
	
	HashMap基于hash表实现，
		哈希表是数组+链表+红黑树，通过哈希算法计算对象在数组中合适位置，
			每个数组中有个链表/红黑树，当链表长度超过8的时候，会转为红黑树。

	hashMap没有加锁，允许多个线程同时操作同一数据，所以线程不安全

	concurrentHashMap采用了分段锁+CAS锁的方式，
		一方面是cas乐观锁加持轻锁优化，另外还采用分段锁进行值对部分段进行加锁，保证一定并发性能

wait和sleep的区别，如果sleep（0）代表什么？

	wait是Object类的方法，用于让当前线程等待，直到另一个线程调用相同对象的notify方法或者等待超时
	wait必须在同步代码块中调用，并且要捕获InterruptedException 中断异常
	调用wait会释放当前线程的锁
	
	sleep方法是Thread类中静态方法，指定休眠时间，不释放锁
	sleep可以再任意地方使用，不需要同步和捕获异常
	sleep方法的精度受到时钟和调度器影响，不能保证休眠时间精确性

	sleep（0）表示：让当前线程放弃CPU执行权，让其他线程有机会执行。


用两个堆模拟实现队列
	一个是入队堆，一个是出队堆，两个堆的排序规则相反。
	队列有： isEmpty、pull、pop、size方法
	其中isEmpty和size方法就是两个堆的是否为空和大小之和
	pull方法： 就是将元素pull到入队堆中
	pop方法：就是将入队堆中元素全部poll出来放到出队堆中，然后出队堆再poll一个元素

MySQL索引越多越好嘛？什么情况适用索引

	索引不是越多越好，因为索引很占用内存，而且索引的增删该效率比较低。

	适用：经常作查询条件、唯一性约束、经常要排序、经常表连接、经常分组或去重的列、大表的查询优化
	

大表连接小表好还是小表接大表好?
	小表接大表：
		可能产生较小中间结果集合，减少连接开销
		更容易利用索引
		
mysql分表查询，越到后面查询越慢的原因？

	索引效率低： 分表数量过多可能导致索引效率下降。
	数据分布不均：分表后数据分布可能不均匀，有些表的数据非常大
	连接开销增加：多分表联查连接开销会随着分表数量增加而增加
	数据冗余：分表可能导致数据冗余或索引冗余增加

	解决：	
		合适索引设计
		分区策略优化
		定期数据清理
		SQL优化
		硬件优化，或者做分布式储存

代码实现微信抢红包

	其实这个操作有点类似于，代码实现商城秒杀
	
	首先进行需求分析: 需要发红包，多人一起抢红包，分配红包金额，领取红包
		发红包：		发送指定金额、个数红包
		抢红包：		抢完为止
		金额分配：	随机分配
		数据持久化：	数据持久化储存
		并发处理：	支持高并发
		过期处理：	过期红包退还
		数据统计：	提供红包被抢信息
		安全：		防止同一用户重复抢

	实现：
		后端java
		mysql数据库：	储存用户信息，红包信息，红包记录
		redis缓存：		缓存红包信息
		kafka消息队列：	处理红包发送、抢夺等异步操作
		SpringBoot：
	
	代码上的简单实现的话，
		用redis高性能和lua脚本实现原子性处理高并发抢红包
		用kafka异步实现红包信息等的处理	

	其实个人觉得，可以在发红包的时候，就提前生成好红包队列金额，然后同步代码块获取对应红包金额，其他的红包处理都可以采用异步执行。



项目中遇到的困难。。。

异常的关键字，遇到异常怎么处理
	try，catch，finally
	
	看异常信息寻找异常原因，debug查询..

集合类，项目中遇到什么集合，List集合在数据很大的时候会变慢吗？
	List、Set、Map、Queue等集合
	
	一般都是list集合，偶尔Set集合。

	可能会变慢，看具体是List集合的哪种实现和操作是什么，比如随机访问还是增删改操作，要根据需求选择


数据库设计要注意哪些问题？
	需求分析：	确保理解业务，包括数据储存需求、访问方式、数据关系等
	模型设计：	设置合理模型，包括实体、字段、关系等
	性能：		考虑数据库性能，包括数据量、查询速度等
	安全：		权限、访问控制、数据加密等
	备份：		设置合理备份和恢复策略
	规范：		命名、主键、索引、数据冗余、注释、安全、版本控制


数据库数据量特别大怎么办？
	分库分表：可以横向分表或者纵向分表
	索引优化
	缓存优化
	批量处理：对大量数据操作进行批处理形式减少数据库连接开销
	数据压缩：对历史数据进行压缩归档
	异步处理：对耗时操作如数据清理、数据导入等操作进行异步处理，避免阻塞主业务数据库操作
	分布式数据库：多节点部署
	定期维护：对数据定期清理维护，索引重建、信息更新、空间整理

说说线程池、线程池启动方式
	线程池是管理线程的一种方式，主要是用来线程复用减小线程的创建和销毁的开销。
	启动方式：
		1. Executors类有几种静态方法可以重建线程池，有定长线程池、自适应线程池、单线程池
		2.自己手动创建线程池，七个参数
			核心线程数、最大线程数、最大空闲时间、时间单位、任务队列、线程工厂、拒绝策略

		线程池可以通过调用execute方法或者submit方法将任务提交给线程池执行，shutdown方法关闭


说说springboot
	springboot的主要功能和特点：
		自动化配置：	对项目的类路径、依赖关系、配置文件扫描，自动配置所需的各种组件
		起步依赖：	可以一次性引入很多常用库和依赖，如SpringWeb、mybatis等
		嵌入式容器：	tomcat、jetty、undertow等，让应用程序独立运行无需外部web服务器
		简化配置：	约定优于配置原则，提供默认配置
		
springboot常见注解
	@SpringBootApplication：	启动=@Configuration+@EnableAutoConfiguration@ComponentScan
	@Controller：		控制器，处理HTTP请求
	@RestController：	类似控制器，但是可以将返回值自动转换为json格式
	@Service：			标识服务层
	@Repository：		标识数据访问层
	@Resources：		自动装配
	@Component：		标识组件
	@Configuration：		表示配置类，其中可以使用@Bean注入Bean
	@Transactional：		spring事务注解

SpringBoot怎么注入？
	用@Autowired或者@Resources注解进行注入，还可以使用构造方法、Setter方法注入
	这两个注解的区别主要是一个首先按照类型匹配，另一个首先按照名称匹配
	autowired注解默认使用构造方法注入，Resource默认使用setter方法注入
	set注入：
		优点：
			可以灵活地在对象实例化后动态设置依赖关系，使得对象的状态更加可变和灵活。
			对于可选依赖或依赖较多的情况，Setter注入可避免构造器参数过多问题，增强可读性和可维护性。
		缺点：
			对象实例化后可能处于不完整的状态，需要额外的处理来确保对象的正确性。
			Setter方法的调用可能会在对象使用之前发生，存在一定的时间窗口，可能会引发多线程安全问题。
	构造器注入：
		优点：
			明确表明对象依赖关系，使对象实例化后即可使用，避免了因为依赖缺失导致对象不完整的问题。
			依赖关系在构造器中一次性注入，确保对象是不可变的，符合单一职责原则和依赖倒置原则。
			构造器注入对强制依赖情况更加直观，如果依赖关系不满足，对象无法被实例化，可以编译时发现。
		缺点：
			如果有大量的依赖关系，构造器会变得很长，不够清晰和易读。
			对于可选依赖或者依赖数量较多的情况，构造器注入可能会显得笨重和复杂。

Spring常见注解
	@Value: 		从配置文件中读取属性值，并注入到Bean中。
	@Profile:	指定在特定环境下激活的Bean配置。
	@RequestMapping: 映射HTTP请求路径到控制器方法，可用于类级别和方法级别。

项目中数据库怎么连接？
	利用mybatis实现，在nacos中写配置，然后启动时读取nacos的配置，
	配置mysql，然后写mybatis的配置文件
	写sql映射文件，也就是mapper
	写代码api，通过接口调用

count（*）和count（1）的区别
	count（*）和count（1）作用一致，
	一般count（*）的性能会好点，因为有mysql特殊优化。但是
			mysql中有时会将count（*）和count（1）采用相同执行计划
	count（字段）：检查字段是否为null，速度相对慢些

索引的分类
	唯一索引：整列唯一的索引
	全文索引：针对文本数据的索引
	空间索引：地理位置的索引
	哈希索引：用hash算法，只支持等值查询
	覆盖索引：索引包含查询所需的数据列，避免回表查询
	聚集索引：一般是主键索引，决定了数据在磁盘中的物理存储顺序

进程和线程

	进程是资源分配的基本单位，而线程是操作系统调度的基本单位。
	进程间相互独立，而线程间共享相同的内存空间和资源。
	线程的切换开销比进程小，因为它们共享了相同的地址空间和其他资源。
	
进程间的通信
	管道		半双工通信，用于父子进程
	消息队列	每个消息都头标识符和数据库，进程通过标识符进行消息发送和接收
	信号量	控制对共享资源的访问
	信号		通知进程发生事件的机制

信号使用
	注册信号处理器，一般使用signal函数或者sigaction函数注册
	定义信号处理器函数，处理接收的特定信号
	发送信号，通过命令行或者其他进程或操作系统发送
	处理信号，进程会调用事先注册的信号处理器函数

同步异步区别
	同步操作会阻塞调用方，异步操作运行调用方执行其他任务
	同步操作按顺序执行，异步操作并发执行
	
IO多路复用
	主要的IO复用技术：
		select()：系统调用，运行程序同时监视多个文件描述符的读写状态
				限制是监视的文件描述符数量有限，一般为1024
		poll()：	系统调用，没有select数量限制
				监视一个文件描述符数组，当文件描述符准备好读或写时，poll将返回
		epoll():	linux特有，大规模并发连接时，性能最好。
				事件驱动，效率高
				使用三个系统调用，一个创建epoll实例，一个控制文件描述符添加和删除，一个等待事件

	减少系统调用次数、提高并发、降低cpu使用率。适用与管理多个IO流的场景，如网络服务器、聊天应用等

如何提高线程效率
	减少线程的数量：避免创建过多的线程，线程的创建和切换会消耗系统资源。
					考虑使用线程池来管理线程，重复利用已有的线程

	避免线程阻塞：	避免线程在执行过程中被阻塞，使用非阻塞的I/O操作、异步操作或使用多线程和多进程结合的方式处理任务。

合理使用同步机制：在多线程环境中，需要合理使用锁、条件变量等同步机制，避免出现死锁和竞态条件。

注意线程间通信：线程间通信需要谨慎处理，选择合适的通信方式（如队列、信号量等），避免频繁的线程间切换和数据拷贝。

优化算法和数据结构：在多线程编程中，选择合适的算法和数据结构可以减少线程间的竞争和冲突，提高程序的并发性能。

使用并发工具和框架：使用现有的并发工具和框架可以简化多线程编程的复杂性，提高开发效率和性能。

合理分配任务：将任务合理地分配给不同的线程，避免某个线程负载过重，导致其他线程处于空闲状态。

注意资源管理：合理管理线程所需的资源，及时释放不再需要的资源，避免资源泄露和浪费。


