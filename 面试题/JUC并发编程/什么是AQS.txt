AQS（Abstract Queued Synchronizer，抽象队列同步器）
		Java并发编程中的一个重要的类，是一个用于构建锁和同步器的框架
		提供了一种基于先进先出队列的方式来管理线程间的竞争和协作 。

核心思想：
	将同步状态（state）抽象为一个整数，通过CAS操作来修改同步状态；
	将等待获取同步状态的线程封装为节点（Node），按照FIFO的顺序组织成一个双向队列（CLH队列），
		同时维护一个指向队列头部和尾部的引用（head和tail）；
		提供一系列的模板方法，让子类可以根据不同的同步语义来实现具体的逻辑 。

AQS有两种模式：独占模式和共享模式。
	独占模式：
		独占模式下，同步状态表示当前持锁的线程可重入的次数，初始值为0，表示没有线程持有锁。
		线程尝试获取锁时，调用AQS的tryAcquire(int arg)方法，方法由子类实现，
			根据不同的锁语义来判断是否能够获取锁。
		如果成功获取锁，就将同步状态设置为arg，并将当前线程设置为独占线程。
			如果失败获取锁，就将当前线程封装为一个节点，加入到等待队列，阻塞当前线程。
		当持有锁的线程释放锁时，调用AQS的tryRelease(int arg)方法，
			方法由子类实现，根据不同锁语义判断是否能够释放锁。
		如果成功释放锁，将同步状态设置为0，将独占线程设置为null。唤醒等待队列中的下一个节			点对应的线程，让它尝试获取锁。实现公平的FIFO队列管理独占锁的竞争和分配。

	独占模式:
		只有一个线程可以获取到同步状态，其他线程必须等待该线程释放同步状态后才能尝试获取；


	共享模式：
		共享模式下，同步状态表示当前可用的资源数量，初始值由子类设定，表示最大的资源数量。
		当线程尝试获取资源时，调用AQS的tryAcquireShared(int arg)方法，方法由子类实现，
			根据不同的策略判断是否能获取资源，并返回int值表示获取后剩余的资源数量。
		如果返回值大于等于0，表示成功获取资源，并将同步状态减去arg；
		如果返回值小于0，表示失败获取资源，将当前线程封装为一个节点，加入到等待队列，
			阻塞当前线程。
		当持有资源线程释放资源时，调用AQS的tryReleaseShared(int arg)方法，方法由子类实现			根据不同的策略判断是否能释放资源，并返回boolean值表示是否需要唤醒后续节点		如果成功释放资源，就将同步状态加上arg；
		如果需要唤醒后续节点，会唤醒等待队列中所有符合条件的节点对应线程，
		让它们重新尝试获取资源。实现了基于资源分配策略管理共享资源的竞争和分配。

	共享模式:
		多个线程可以同时获取到同步状态，根据不同的策略来分配资源 。


AQS是一个抽象类，不能直接使用，要继承它并实现它的一些方法。

	Java中有很多基于AQS实现的锁和同步器，
	如ReentrantLock, ReentrantReadWriteLock, Semaphore, CountDownLatch, CyclicBarrier等








