synchronized是Java语言中用于处理线程安全问题，实现线程间的同步的关键字。

可以保证并发编程的三大特性：原子性、可见性和有序性。

	原子性：
		一个或多个操作要么全部执行成功，要么全部执行失败。
		synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。

	可见性：
		当一个线程对共享变量进行修改后，其他线程可以立刻看到。
		执行synchronized时，会对应执行lock、unlock原子操作，保证可见性。

	有序性：
		程序的执行顺序会按照代码的先后顺序执行。
		synchronized关键字能够保证被修饰的代码同一时间只有一个线程执行，
		即使进行了指令的重排序，也不会影响程序运行结果。

synchronized关键字有三种使用方式：修饰普通同步方法、修饰静态同步方法、修饰同步方法块³。

	修饰普通同步方法：相当于对当前实例对象this加锁，this作为对象监视器。
	修饰静态同步方法：相当于对当前类的Class对象加锁，当前类的Class对象作为对象监视器。
	修饰同步方法块：	指定加锁对象，对给定对象加锁，括号括起来的对象就是对象监视器。

synchronized关键字的底层原理
	通过Java对象头和monitor对象来完成的。

	Java对象头：每一个Java对象都有一个对象头，包含了Mark Word和Klass Pointer两部分数据。
		Mark Word用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志等。K
		lass Pointer是对象指向它的类元数据的指针，用于确定对象的类型。
	
	monitor是一个同步工具，内置在每一个对象中，任何一个对象都有一个monitor与之关联。
	synchronized在JVM里的实现就是基于进入和退出monitor实现的，
	底层是通过成对的monitorenter和monitorexit指令来实现。

	monitorenter：
		如果当前monitor的进入数为0时，线程就会进入monitor，并且把进入数+1，
			那么该线程就是monitor的拥有者。
		如果该线程已经是monitor的拥有者，又重新进入，就会把进入数再次+1。
		也就是可重入的。
	monitorexit：
		执行monitorexit的线程必须是monitor的拥有者，指令执行后，monitor的进入数减1，
		如果减1后进入数为0，则该线程会退出monitor。
		其他被阻塞的线程就可以尝试去获取monitor的所有权。

	当多个线程同时访问同步代码块时，
	首先会进入到EntryList中，通过CAS的方式尝试将Monitor中的owner字段设置为当前线程，
	同时count加1，若发现之前的owner的值就是指向当前线程的，recursions也需要加1。
	如果CAS尝试获取锁失败，则进入到EntryList中。
	当获取锁的线程调用wait()方法，则会将owner设置为null，同时count减1，recursions减1，
	当前线程加入到WaitSet中，等待被唤醒。
	当前线程执行完同步代码块时，则会释放锁，count减1，recursions减1。
	当recursions的值为0时，说明线程已经释放了锁。

在JDK1.6后，synchronized关键字进行了优化，引入了偏向锁、轻量级锁、自旋锁等概念。

偏向锁：		即无锁竞争的情况下,取消同步操作
	假设一个线程获得了锁，并且没有其他线程竞争该锁，
	则该线程再次请求该锁时，无需进行任何同步操作。
	这种情况下，只需要在对象头中记录下获取过该锁的线程ID即可。

轻量级锁：	即锁竞争比较少的时候,自旋获取锁
	假设一个线程获得了锁，且有其他线程竞争该锁，则该线程会将对象头中的部分信息复制到栈帧中，
	并将对象头中的标志位设置为轻量级锁状态。其他竞争线程会尝试使用CAS操作获取锁，
	如果成功则继续执行，如果失败则自旋等待。

自旋锁：				
	假设一个线程没有获取到轻量级锁，则它不会立即阻塞，而是进行一定次数（时间）的循环检测锁
	是否被释放。这种方式避免了线程切换的开销，但如果自旋时间过长，也会浪费CPU资源。
	自旋锁是自适应的，即自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及
	锁的拥有者的状态来决定。




