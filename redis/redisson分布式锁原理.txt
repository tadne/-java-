
redisson分布式锁原理

获取锁:
	开始==>尝试获取锁==>判断ttl是否为null
		==>为null==>即获取锁成功==>判断leaseTime是否为-1
							==>是==>开启看门狗watchDog==>返回true
							==>不是==>返回true==>结束
		==>不为null==>判断剩余等待时间是否大于0
				==>是==>订阅并等待释放锁的信号
						==>判断等待时间是否超时
							==>是==>返回false==>结束
							==>不是==>尝试获取锁
				==不是==>	返回false==>结束	
	
	注	:		看门狗是用来延长过期时间的,来避免出现
					线程执行时间过长导致锁过期的情况
					线程宕机或断网会停止延长有效期
					
释放锁
	开始==>尝试释放锁==>判断是否成功
			==>否==>记录异常==>结束
			==>是==>发送释放消息==>取消看门狗watchDog==>结束


		
	总结:	redisson是如何解决分布式问题的?

		可重入:	利用hash机构记录线程id和重入次数
		可重试:	利用信号量和PubSub功能实现等待,唤醒,获取锁失败的重试机制
		超时续约:	利用看门狗watchDog,每隔一段时间(releaseTime/3),重置超时时间	



主从一致性:
		Redis提供了主从集群,其中主节点处理写操作,从节点处理读操作,实现读写分离提供并发吞吐

		但是主从要做数据同步,数据同步有延时

		如果在获取锁时,数据同步没有完成,并且主节点宕机了,这时redis会让从节点变成节点恢复业务

		但是主节点中的锁就丢失了,导致锁失效


	解决:	redisson在获取锁时,会对所有节点发请求获取锁,放弃读写分类
			但是要拿到每一个实例的锁才行,效率比较慢

















	


	
