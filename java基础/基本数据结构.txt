栈:		先进后出,后进先出			如:	虚拟机栈,本地方法栈等

队列:	先进先出,后进后出			如:	ArrayBlockingQueue,PriorityQueue

数组:	查询快:	通过地址值和索引定位,查询任意数据耗时相同	(元素在内存中是连续储存的)
	删除慢:	将原始数据删除,同时后面元素后移,再添加
	添加慢:	添加位置后的数据后移,在添加元素
链表
	单向链表:	节点:	数据,下一个节点地址值,(元素在内存中是不连续的)
			查询慢:	无论查什么数据都要从头开始
			增删快:	只要将对应节点的地址值修改就可以了
	
	双向链表:	节点:	前一个节点的地址值,数据,后一个节点的地址值
		



树:	二叉树:	任意节点的子节点数量<=2
		节点:	父节点地址,左子节点地址,右子节点地址,值
	
		遍历:	前序,中序,后序,层序
			前序:	从根开始,按照中,左,右顺序遍历
			中序:	从最左边的子节点开始,左,中,右 顺序遍历
			后序:	从最左边的子节点开始,左,右,中 顺序
			层序:	一层一层遍历

		二叉树弊端:		只能一个一个遍历才能获取

	二叉查找树:	从根节点开始,大的往右,小的往左,一样不存
			查找效率高,一般用中序遍历,因为是从小到大排列

		二叉查找树弊端:	当出现连续递增的数字添加的时候,会将层级变高,降低效率
	
	平衡二叉树:	从根节点开始,大的往右,小的往左,一样不存
			任意节点左右子树高度差不超过1
			
		通过旋转来保持树的高度

		左左:	当根节点左子树的左子树有节点插入,导致二叉树不平衡		:一次右旋
		左右:	当根节点左子树的右子树有节点插入,导致二叉树不平衡		:两次左旋
		右右:	当根节点右子树的右子树有节点插入,导致二叉树不平衡		:一次左旋
		右左:	当根节点右子树的左子树有节点插入,导致二叉树不平衡		:两次右旋

	红黑树:		节点: 父节点地址,值,左子节点,右子节点,颜色	
	
			自平衡的二叉查找树,也叫二叉B树
			每一个节点有储存节点的颜色,可以是红或者黑,不是高度平衡的,按照红黑规则实现

		 红黑规则:	每一个节点要么黑要么红
				根节点是黑色
				如果一个节点没有子节点或父节点,那就设子节点为Nil,叫叶节点,黑色
				如果节点是红色,那么子节点不能是黑色
				每一个节点,从该节点到其后代节点的简单路径上,都包含相同数目黑色节点

	      红黑树添加规则
		根节点		直接变成黑色
		非根:	父黑:	不操作
			父红:	叔红:将父设黑,叔设黑,祖父设红,若祖父为根再变黑,
					若祖父非根,将祖父设为当前节点再次判断
				叔黑且当前节点为右子节点:	将父作为当前节点左旋,再判断
				叔黑且当前节点为左子节点:	将父设黑,祖父设红,祖父为支点右旋

	B树	:	一种自平衡的树形结构,	一个节点可以存多个键值,不限制在二叉上
			层级低,方便快速查找和插入数据

	B+树:	在B树上做了优化.
			非页子节点都只储存键,不储存值,来让一个节点可以存更多的键,缩小层级
			叶子节点储存所有的值,并对页子节点的数据建立单向链表,优化范围查询
			












			
		
		