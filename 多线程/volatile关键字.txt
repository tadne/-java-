
volatile
		保证一个线程对这个变量的修改，另外一个线程立马可以看到



JMM(Java Memory Model)Java内存模型
		是java虚拟机规范中所定义的一种内存模型。

		描述了Java程序中各种变量(线程共享变量)的访问规则，
			以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。

特点：

		所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。
		不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。

		每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。

		线程对变量的所有的操作(读，写)都必须在工作内存中完成，不能直接读写主内存中的变量，
		不同线程之间不能直接访问对方工作内存的变量，线程间变量的值的传递需要通过主内存完成。


		从主内存中读取数据到工作内存
		对工作内存中的数据进行++操作
		将工作内存中的数据写回到主内存

	
	
	就是在出现子线程的变量要修改,主线程要用到子线程变量的时候,就要小心内存更新不及时的问题


解决方案:	1:	锁,在主线程类中给出问题的方法上锁
		2:	volatile关键字来修饰问题变量
		
		原理:	volatile关键字保证不同线程对共享变量操作的可见性，
			也就是线程修改了volatile修饰的变量写回主内存时，其他线程立即看到最新的值。

	volatile与synchronized的区别：

		volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。

		volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);
		synchronized是一种排他（互斥）的机制,
			synchronized修饰的代码块，被修饰的代码块称之为同步代码块，
			无法被中断可以保证原子性，也可以间接的保证可见性。


	原子性举例
		线程A需要对变量进行自增1的操作，需要从主内存中读取变量count的值。
		由于CPU的切换关系，CPU执行权切换到了B线程。A线程就处于就绪状态，B线程处于运行状态。		线程B也从主内存中读取count变量的值,由于线程A没有对count值做修改,故B读取的还是100
		B工作内存中对变量执行+1操作，但是未刷新到主内存中
		此时CPU的执行权切换到了A，此时B没有将工作内存中的数据刷新到主内存，
		故A线程工作内存中的变量值还是100，没有失效。A线程对工作内存中的数据进行了+1操作。
		线程B将101写入到主内存
		线程A将101写入到主内存

		其实就是每次从主内存读数据和写数据都要重新抢夺cpu导致的





























