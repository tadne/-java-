缓冲更新策略:

					
	内存淘汰		:	不用维护,redis的内存淘汰机制就是当内存不足时淘汰部分数据,下次查询时更新缓存

				一致性不好,没有维护成本

	超时剔除		:	给缓冲数据添加TTL时间,到期后自动删除缓存,下次查询时更新缓存
	
				一致性一般,维护成本低

	主动更新		:	编写业务逻辑,在修改数据库的同时更新缓存
	
				一致性较好,但是维护成本较高


	业务场景:		低一致性需求就使用默认的内存淘汰机制
				高一致性需求就使用主动更新并使用超时剔除为兜底,二者结合使用



主动更新策略:

	cache aside pattern :	缓冲的调用者,在更新数据库的同时更新缓存(常用方式)

	read/write through pattern:
						缓冲和数据库整合为一个服务,由服务来维护一致性,
						调用者调用该服务,无需关心缓存一致性问题

	write behind caching pattern:
						调用者只操作缓存,其他线程异步将缓存数据持久化到数据库,保证最终一致





缓存和数据的问题

	删除缓存还是更新缓存?
	
		更新缓存:		每次更新都更新缓存,会导致无效写操作太多
		删除缓存:		更新数据库时让缓存失效,查询时更新缓存

	如何保证缓存与数据库的操作的同时成功与失败?

		单体系统,将缓存和数据库放一个事务中
		分布式系统,用tcc等分布式事务方案

	先操作缓存还是先操作数据库?

		先删除缓存,再操作数据库:		
			线程1:	删除缓存,										再更新数据库
			线程2:			查询缓存,没有,	所以查询数据库,写入缓存
	
			导致数据不一致(发生概率高,因为更新数据库更耗时)

		先操作数据库,再删除缓存:
			线程1:	查询缓存									写入缓存
			线程2:				更新数据库		删除缓存

			导致数据不一致(发生概率不高,因为查询缓存和写入缓存的时间很短)

	
		所以,先操作数据库再更新缓存更好!

		
		
