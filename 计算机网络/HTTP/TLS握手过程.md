## TLS握手过程

HTTP是明文传输，所以客户端和服务端通信信息可见，导致抓包工具可以截获通信的内容，所以有安全风险
- 窃听，如通信链路上可以获取通信内容
- 篡改，如强制植入垃圾广告等
- 冒充，如冒充淘宝网址

HTTPS在HTTP与TCP层之间加了TLS协议解决上述安全问题


#### TLS如何解决HTTP风险
- 信息加密：HTTP交互信息被加密，第三方无法窃取
- 校验机制：校验信息传输过程被第三方篡改，会有警告提示
- 身份证书：证明服务器身份

其中HTTPS是应用层协议，要先完成TCP连接，然后走TLS握手过程，再建立安全连接
不过，不同的密钥交换算法，TLS握手过程可能会有些许不同

密钥交换算法： 考虑性能问题，加密应用信息时用得时对称加密密钥，不能泄露。为了保证对称加密密钥安全性，采用非对称加密方式保护对称加密密钥的协商。这个工作由密钥交换算法完成。

### RSA握手过程
传统TLS基本都是用RSA实现的，将TLS证书不熟服务端时，证书文件其实就是服务器端的公钥，在TLS握手阶段传递给客户端，服务端的私钥一直保留在服务端，确保私钥不能被窃取

在RSA密钥协商算法中，客户端生成随机密钥，使用服务端公钥加密传输给服务端，根据非对称加密算法，加密的信息只能通过私钥解密，服务端解密后，双方就得到相同密钥，再用它加密应用信息。

TLS四次握手过程
1.第一次握手
  - 客户端发送ClientHello，消息中包含客户端使用的TLS版本、密码套件列表、客户端生成的随机数（ClientRandom），随机数会被服务端保留，它是生成对称加密密钥的材料
2. 第二次握手
  - 服务端收到ClientHello后，确认TLS版本号是否支持，从密码套件列表中选一个密码套件，生成随机数（ServerRandom）
  - 密码套件基本组成： 密钥交换算法+签名算法+对称加密算法+摘要算法。前两次握手确定了TLS的版本和密码套件，而随机数就是对称加密的密钥
  - 服务端再发送ServerCertificate给客户端，这个消息中有数字证书，随后服务器发送ServerHelloDone消息，完毕
3. 客户端验证证书
  - 数字证书和CA机构
    - 数字证书包含了： 公钥、持有人信息、证书认证机构的信息、CA对文件的数字签名以及使用的算法、证书有效期、额外信息
    - 作用：认证公钥持有者的身份，也就是认证服务器的身份。
    - 证书来自CA机构签名，签名作用：避免中间人获取证书时对证书内容篡改
  - 数字证书签发
    - CA将持有者公钥、用途、颁发者、有效时间打包，对信息进行Hash计算得到Hash值
    - CA使用私钥将这个Hash加密，生成Certficatesignature，也就是CA对证书签名
  - 数字证书验证流程
    - 客户端使用同样Hash算法获取Hash值H1
    - 浏览器一般集成了CA公钥信息，收到证书后用CA的公钥解密，得到一个Hash值H2
    - 最后比较两个哈希值，如果值相同就是可以信赖的证书
  - 证书链
    - 证书验证过程中还有证书信任链问题，一般申请的证书都不是CA的根证书签发，而是中间证书签发，比如百度的证书。
    - 通常客户端收到百度证书，发现不是根证书，就根据证书的签发者找证书的颁发机构，不断溯源，直到找到CA颁发，向CA请求下级证书，再根据根证书的公钥逐个验证下级证书。
    - 证书链这么麻烦的原因是为了隔离根证书，避免根证书泄露
4. TLS第三次握手
  - 客户端验证完证书后会生成一个新随机数（pre-master）,用服务器的RSA公钥加密该随机数，通过ClientKeyExchange消息传给服务端
  - 服务端收到后用RSA私钥解密，得到随机数（pre-master）
  - 至此，客户端和服务端都获取到了三个随机数（Client-Random）(Server-Random)(pre-master)
  - 接下来双方根据三个随机数生成会话密钥，它是对称密钥（MasterSecret），用于对后续HTTP请求、响应的数据加密和解密
  - 生成密匙后，客户端发送ChangeCipherSpec，告诉服务端开始使用加密方式发送消息
  - 客户端再发EncryptedHandshakeMessage消息，将之前发送的数据做摘要，用会话密匙加密，让服务器做验证，验证加密通信的可用性和是否被篡改
5. TLS的四次握手
  - 服务端同样操作，发送ChangeCipherSpec和EncryptedHandshakeMessage，如果双方都验证加密和解密没问题，那么握手正式完成

## RSA算法的缺陷

**使用RSA密钥协商算法的最大问题是不支持前向保密**

因为客户端传递随机数给服务端时使用的是公钥加密，服务端收到后用私钥进行解密，所以一旦服务端私钥泄露，过去所有被截获的TLS密文都会被破解


之后的ECDHE密钥协商算法解决了这个问题。

