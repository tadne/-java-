## HTTP缓存技术

### HTTP缓存有哪些实现方式

对于重复性的HTTP请求，如相同get请求，可以将【请求-响应】缓存到本地，下次请求直接读取本地缓存，不必发到服务器获取响应，提高性能

因此，HTTP头部有针对缓存的字段，有两种实现方式，分别是强制缓存和协商缓存

#### 强制缓存

只要浏览器判断缓存没有过期，就直接使用浏览器的本地缓存，决定是否用缓存的主动性在于浏览器。

实现方式：利用两个HTTP响应头部实现，都是用来表示资源在客户端缓存的有效期：

```
Cache-Control，相对时间
Expires，绝对时间
```

如果同时有这两个字段，Cache-control优先。

Cache-control选项更多，设置更精细，具体实现：

1. 当浏览器第一次访问服务器资源时，服务器会子啊返回这个资源的同时，在response头部加Cache-control字段，其中设置了过期时间大小
2. 浏览器会再次访问服务器中的该资源时，先通过请求资源的时间与过期时间比较，计算是否过期
3. 浏览器再次收到请求后，再次更新Response头部的Cache-control


#### 协商缓存

浏览器使用开发工具时，有些请求响应码是304，这个就是告诉浏览器可以使用本地缓存资源，这种服务端告知客户端的缓存方式就是协商缓存

实现：基于两种头部实现

1. 请求头部中的 If-Modified-Since 字段与响应头部的 Last-Modified 字段实现
   1. 响应头部的Last-Modified：标识这个响应资源的最后修改时间
   2. 请求头部的If-Modified-Since：当资源过期过期，发现响应头中的有Last-Modified声明，就再次发请求带上Last-Modified时间，服务器收到后发现If-Modified-Since就与被请求资源的最后修改时间进行对比，如果修改时间比较新说明资源被改过，返回新资源，否则会响应304走缓存
2. 请求头部中的If-None-Match字段与响应头部中的Etag字段，
   1. Etag：唯一标识响应资源
   2. If-None-Match:资源过期时，浏览器发现响应头中有Etag，就再次向服务器发请求，将请求头If-None-Match值设置为Etag的值，服务器收到请求后对比，如果资源没有变化就返回304，变化了就返回200
3. 第一种基于时间实现，第二种基于唯一标识实现，相对的后者可以更准确的判断文件内容是否被修改，避免时间篡改导致的不可靠问题。
4. 同时带有两种字段的情况下，Etag优先级更高，先看Etag是否变化，如果Etag不变再看Last-Modified。因为有些服务器不能精确获取文件最后修改时间以及请求时间可能间隔很短为秒级别。


ETag 字段实现的协商缓存的过程：

* 浏览器第一次请求访问服务器，服务器在 Response 头部加上 ETag 唯一标识并返回资源，这个唯一标识的值是根据当前请求的资源生成的；
* 浏览器再次请求访问服务器中的该资源时，会先检查强制缓存是否过期：
  * 如果没有过期，则直接使用本地缓存；
  * 如果缓存过期了，在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
* 服务器再次收到请求，**会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较**：
  * **如果值相等，返回 304 Not Modified，不返回资源**；
  * 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
* 如果浏览器收到 304 的请求响应状态码，会从本地缓存中加载资源，否则更新资源。
