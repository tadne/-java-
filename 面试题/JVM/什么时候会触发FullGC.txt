Full GC:	一种针对整个堆内存的垃圾回收行为，会清理新生代、老年代和元空间(老年代)中的无用对象。
		Full GC通常比MinorGC和MajorGC耗时更长，
		因为需要暂停所有的用户线程，扫描和回收整个堆空间。

触发Full GC的情况有以下几种：

	调用System.gc()方法，建议虚拟机执行Full GC，但不一定会真正执行。
		这种方式不推荐使用，应该让虚拟机自己管理内存。

	老年代空间不足，无法为新生代晋升的对象分配足够的空间。
		可能是由于创建了过大的对象或数组，或者新生代对象存活时间过长而进入老年代。
		为了避免这种情况，可以调大老年代的大小，或调整新生代的大小和对象晋升的年龄阈值。

	元空间（永久代）空间不足，无法为加载的类、常量、静态变量等数据分配足够的空间。
		可能是由于系统中要加载的类、反射的类和调用的方法较多。
		为了避免这种情况，可以调大元空间（永久代）的大小，或者使用CMS GC3。

	空间分配担保失败:	
		MinorGC前，虚拟机检查老年代最大可用的连续空间是否大于新生代所有对象总空间，
		如果不成立，则可能触发Full GC1。
		
		为了避免这种情况，可以调整堆内存的初始大小和最大大小，或者关闭空间分配担保机制。

	CMS GC时出现promotion failed或concurrent mode failure，
	即在进行CMS GC过程中，有对象要放入老年代而空间不足造成的。
		这种情况下会退化使用Serial Old收集器变成单线程的。
		为了避免这种情况，可以增加老年代的预留空间，或者降低触发CMS GC的阈值。

	堆中分配很大的对象，即需要大量连续内存空间的java对象，如很长的数组。
		这种对象会直接进入老年代，老年代虽然有很大的剩余空间，
		但无法找到足够大的连续空间来分配给当前对象。
		为了避免这种情况，可以使用CMS GC，并开启碎片整理和压缩机制。


如果想要排查频繁发生Full GC的原因，可以使用以下方法：

	开启GC日志记录，并使用工具分析日志中的GC信息，如GC类型、触发原因、回收时间、回收效果等。
	使用jmap命令查看堆内存中各个区域的使用情况和对象分布情况。
	使用jstat命令查看堆内存中各个区域的容量和占用率等统计信息。
	使用jvisualvm或jconsole等可视化工具监控堆内存和GC状况，并进行性能分析和故障排查。