线程安全问题

	非线程安全:	多个线程对同一个对象的实例变量进行操作时,出现值被修改不同步的情况.
			主要分为三个方面,原子性,可见性和有序性


	原子性(Automic)	:原子性是不可分割的意思.
				访问某个共享变量的操作从其他线程来看,要么执行完毕,要么没有发生
				访问同一组共享变量的操作不能交错
				即对于用户来说,要么发生要么没有发生
		
			java有两种方式实现:	
				使用锁	锁有排他性,保证共享变量在某一时刻只能被一个线程访问

				使用处理器的CAS	CAS指令直接在硬件(处理器,内存)上实现,看做硬件锁
		

	可见性:		在多线程环境中,一个线程对某个共享变量进行更新后,后续其他线程可能无法立即读			取到这个更新后的结果.这就是线程安全问题的另一种形式

			如果一个线程对共享变量更新后,后续访问该变量的其他线程可以读到更新的结果,
			称这个线程对共享变量的更新对其他线程可见,否则不可见
		
			多线程因为可见性问题可能会导致其他线程读取到旧数据,导致脏读

				1.因为JIT即时编译器可能会直接储存变量的值,导致没有再次读取
				2.可能与计算机储存系统相关,两个cpu运行两个线程,
					一个cpu可能无法立即读取另一个cpu中数据


	有序性		在一些情况下一个处理器上运行一个线程所执行的内存访问操作
			在另一个处理器运行的其他线程看来是乱序的
	
			乱序:	内存访问操作的顺序看起来发生了变化


			重排序:	在多核处理器的环境下,编写的顺序结构,执行顺序可能是没有保障的
				编译器可能会改变两个操作的先后顺序
				处理器也可能不会按照目标代码的顺序执行
			重排序是对内存访问有序操作的一种优化,可以在不影响单线程程序正确的情况下
				提升程序性能,但是,可能对多线程程序正确性产生影响导致线程安全问题

		与内存操作顺序有关的几个概念:
			源代码顺序,就是源码中指定的内存访问顺序
			程序顺序,处理器上运行的目标代码指定的内存访问顺序
			执行顺序,内存访问操作在处理器上的实际执行顺序
			感知顺序,给定处理器所感知到的该处理器及其他操作的内存访问操作顺序

		可以把重排序分为指令重排序与储存子系统重排序两种
			指令重排序:	由JIT编译器,处理器引起的,指程序顺序与执行顺序不一致导致
			储存子系统重排序:	由高速缓冲,写缓冲器引起的,感知顺序与执行顺序不一致导致
		
		指令重排序是一种动作,确实对指令的顺序做了调整,重排序的对象是指令
			javac编译器一般不会执行指令重排序,而JIT编译器可能执行指令重排序
			处理器也可能执行指令重排序,使得执行顺序和程序顺序不一致
			
			指令重排不会对单线程程序的结果正确性造成影响,但是多线程下可能有线程安全问题


		存储子系统重排序
			存储子系统是指写缓冲器与高速缓存
			高速缓存:cpu中为了匹配与主内存处理速度不匹配而设计的一个高速缓存
			写缓冲器:用来提高写高速缓存操作的效率
			
			即使处理器严格按照顺序执行两个内存访问操作,在储存子系统的作用下,其他处理器			对这两个操作的感知顺序与程序顺序不一致,即这两个操作的执行顺序看起来像是发生			了变化,这种现象叫存储子系统重排序
	
			它并没有真正的对指令执行顺序进行调整,而是造成一种指令执行顺序被调整的假象

			存储子系统重排序操作,是内存操作的结果

			从处理器角度看,
				读内存就死从指定RAM地址中加载数据到寄存器,称为Load操作
				写内存就是把数据存储到指定地址表示的RAM储存单元中,称为STore操作
			
			内存重排序有以下四种可能:
			LoadLoad重排序:	在一个处理器先后执行两个读操作L1和L2,其他处理器对内存操					作的感知顺序可能是L2和L1
			StoreStore重排序:一个处理器先后执行两个写操作w1和w2,其他处理器对两个内存					操作的感知瞬可能是w2和w1
			LoadStore重排序:一个处理器先后执行读操作L1和写操作w1,其他处理器对两个内存					操作的感知瞬可能是w1和L1
			StoreLoad重排序:一个处理器先后执行读操作w1和写操作L1,其他处理器对两个内存					操作的感知瞬可能是L1和w1
		
			内存重排序与具体的处理器微架构有关,不同架构的处理器所运行的内存重排序不同
			内存重排序可能会导致线程安全问题.如:有两个共享变量


		貌似串行语义
			JIT编译器,处理器,储存子系统是按照一定规则对指令,内存操作的结果进行重排序
			给单线程造成一种假象--指令是按照源码的顺序执行的,这种假象加貌似串行语义



	java内存模型
			
