## HTTP2

### HTTP1的问题
- 消息太大，而且页面资源变多
- 内容形式变多样，文本到图片到视频
- 实时性要求变高
以上这些导致HTTP1的高延迟，影响用户体验。原因：
- 延迟难以下降，虽然网络带宽变多，但是延迟有一个下限
- 并发链接有限，谷歌浏览器最大并发链接为6，每个链接都要经过TCP握手和TCP慢启动问题
- 队头阻塞问题
- HTTP头部太大并且重复
- 不支持放弃推送消息

###　HTTP2优势

#### 兼容HTTP1
HTTP2的目的就是改善HTTP的性能，协议升级有一个地方，就是兼容老版本的协议，否则推广很困难

- HTTP2在URL中引入新的协议名，仍然用http://来表示明文，https://来表示加密协议。只要在浏览器和服务器升级协议就可以让用户意识不到，实现协议升级
- 只在应用层做改变，基于TCP协议传输，应用层为了保持功能上的兼容，HTTP2将HTTP分解为语义和语法两部分，语义不变，如请求方法、状态码、头字段不变。但是语法变量很多，基本改变了HTTP报文的传输格式

#### 头部压缩
HTTP协议报文由Header+Body构成，Body部分可以使用头字段的Content-Encoding指定Body压缩方式，如gzip压缩等方式，节约带宽。但是Header没有好的优化手段

HTTP1在头部的问题：
- 含有很多固有字段，如Cookie、UserAgent等，加起来高达几百字节，有必要压缩
- 大量请求的字段值都是一致的，要避免重复
- 字段是ASCII编码，易于观察但是销量低，有必要改为二进制编码

HTTP2对Header部分改造，解决了以上问题。

HTTP2没有使用常用的gzip压缩头部，而是使用HPACK算法，这个算法包括三个组件
- 静态字典
- 动态字典
- Huffman编码
客户端和服务器两端都建立和维护字典，用长度小的索引号表示重复的字符串，再用Huffman编码压缩数据，达到50%-90%压缩率

静态表编码： 就是构建了一个数字到头部字段的映射存在表中。
  
动态表编码：只含61种高频出现在头部的字符串，不在静态表中就要自行构建动态表，它的Index从62起步，在编码解码时随时更新

如：第一次发送头部的User-Agent字段数据与上百字节，经过Huffman编码后发送，服务端和客户端都会更新字节的动态表，添加一个新的Index。**在下一次发送的时候，就不重复发送这个字段数据，只发对应Index即可**。

- 使动态表生效的前提：**必须在同一个连接上，重复传输相同头部时**

问题： 动态表越大，占用内存越大，会影响服务器性能的。一般会进行配置限制一个连接传输的请求数量，避免动态表无限增大

总之，头部压缩是依靠 【动态表、静态表、Huffman编码】实现

#### 二进制帧
HTTP2将HTTP1的文本格式改为二进制格式传输数据，极大提高了传输效率，而且二进制数据可以用位运算高效解析。

HTTP2将响应划分为两类帧，一种是首部，一种是消息负载。一条HTTP，划分为两类帧传输，采用二进制编码

- 二进制帧结构： 帧长度24bit、帧类型8bit、标志位8bit、R1bit、流标识符31bit、实际传输的数据
- 帧头（FrameHeader）包括： 帧长度24bit、帧类型8bit、标志位8bit、R1bit、流标识符31bit。实际数据为帧负载（FramePlayload）。
    - 帧头很小，9字节。开头前3字节表示帧数据长度，后一个字节表示帧类型。
      - HTTP2定义了10种帧类型，一般是数据帧和控制帧的分类。 
    - 帧类型后一个字节是标志位，可以保存8个标志位，用于携带简单控制信息。
      - END_HEADERS ：头数据结束标志，相当于 HTTP/1 里头后的空行（“\r\n”）；
      - END_Stream ：单方向数据发送结束，后续不会再有数据帧。
      - PRIORITY ：流优先级；
    - 最后四个字节为流标识符，最高位保留不用，31位可使用，最大值为2^31
      - 作用： 标识该Frame属于哪个stream,接受方根据这个信息从乱序的帧中找相同StreamID的帧
- 帧数据放在最后，存放的是HPACK算法压缩的HTTP头部和包体

#### 并发传输
HTTP1是基于请求响应模型，一个连接中只能完成一个事务才能处理下一个，如果一个事务等不到响应，就会阻塞。

**HTTP2采用Stream设计，多个Stream复用一个TCP连接，达到并发效果，解决对头阻塞问题。**

Stream是HTTP2实现并发的关键。

- 一个HTTP连接包含多个Stream
- Stream中包含多个Message，Message包含HTTP1中的请求和响应，由HTTP头和包体构成
- Message中包含多个Frame，Frame是HTTP2的最小单位，以二进制格式存放HTTP1的内容。

结论：多个Stream跑在一个TCP上，同一个HTTP请求和响应跑在同一个Stream中，HTTP消息由多个Frame构成，一个Frame可以由多个TCP报文组成

- HTTP2连接上，不同Stream帧是可以乱序发送，每个帧头部会携带StreamID信息，接收端可以通过StreamID有序组装HTTP消息，同一个Stream内部帧必须严格有序
- 客户端和服务端双方都可以建立Stream，客户端必须是奇数，服务端必须是偶数
- 同一个连接中的StreamID不能复用，只能顺序递增，ID耗尽后要发送一个控制帧GOAWAY关闭TCP连接。
  - Nginx中，可以设置http2_max_concurrent_Streams配置Stream上限，默认128个
- HTTP2通过Stream实现并发，而且**HTTP2实现100个并发Stream时，只用建立一次连接**
- HTTP2还可以设置Stream的优先级，帧头标志位设置优先级，如服务器传递HTML/CSS和图片时，可以设置先传递HTML

#### 服务器主动推送资源
HTTP1不支持服务器主动推送，只能客户端请求后响应。
- 主动推送的好处：
  - 例：客户端需要请求HTML和CSS资源，那客户端请求HTML的时候，服务端可以响应两个消息，HTML和CSS，减少了客户端的一次CSS请求
    - Nginx中，想要客户端访问/test.html的时候，直接推送test.css。可以配置：


      location /test.html{
          http2_push /test.css;
      }

- 实现：
  - 客户端发起请求必须是奇数Stream，服务器的推送是偶数Stream，
  - 服务器推送资源时，通过PUSH_PROMISE帧传输HTTP头部，通过帧中PromisedStreamID告知客户端接下来哪个偶数Stream中发送包体
  - 解释： 其实就是传输html的Stream中会带有css响应的StreamID。但是要注意的是两个Stream时可以并发的。



#### 总结
主要介绍了：HTTP2如何提升性能的方向。
- HTTP头部采用静态表和Huffman编码将体积压缩一般，还可以针对之后的请求头建立动态表，将体积压缩90%
- HTTP2实现Stream并发，多个Stream只需一个TCP连接
- 服务器支持主动推送资源，提升消息传输性能

问题： 
- **Stream并发解决了应用层队头阻塞问题，但HTTP2采用的是TCP连接，TCP连接在传输数据的时候只能传输连续完整数据，那么当前一字节数据没到就只能在内核缓冲区等待，导致会在TCP传输层阻塞**
- 解决： 放弃TCP协议，采用UDP协议作为传输层协议。