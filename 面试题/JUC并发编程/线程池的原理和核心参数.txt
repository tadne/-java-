线程池
	一种并发编程的工具，可以管理和复用多个线程，避免频繁地创建和销毁线程，提高系统性能和资源利用率


线程池的原理：
	当任务提交到线程池时，线程池会根据当前的线程数量和状态，
		决定创建新线程来执行任务，还是将任务放入一个阻塞队列中等待执行，或者拒绝执行任务。


线程池的执行流程：

	如果当前线程池中的线程数量小于核心线程数（corePoolSize），则创建新的线程来执行任务；

	如果当前线程池中的线程数量等于或大于核心线程数，则将任务放入工作队列中等待执行；

	如果工作队列已满，且当前线程池中的线程数量小于最大线程数，则创建新的线程来执行任务；

	如果工作队列已满，且当前线程池中的线程数量等于或大于最大线程数，则根据拒绝策略来处理任务。





线程池的核心参数:	
	
	线程池中的核心线程数(corePoolSize):	即最小的线程数量。
		核心线程一直存活，即使没有任务需要执行，除非设置了allowCoreThreadTimeOut为true
		当任务提交到线程池时，如果当前线程数小于corePoolSize，会创建新的线程来执行任务。


	线程池中的最大线程数(maximumPoolSize)：	即能够容纳同时执行的最大线程数。

		当任务提交到线程池时，如果当前线程数达到corePoolSize，且工作队列已满，
		会创建新的线程来执行任务，直到达到maximumPoolSize。
		如果超过maximumPoolSize，就会执行拒绝策略。

	空闲线程的存活时间(keepAliveTime)：	即当非核心线程空闲的时间，
		这个参数可以控制线程池的空闲资源回收。


	工作(阻塞)队列(workQueue):		用于存放待执行的任务

		当任务提交到线程池时，
			如果当前线程数小于corePoolSize，会创建新的线程来执行任务；
			如果当前线程数等于或大于corePoolSize，会将任务放入工作队列中等待执行；
			如果工作队列已满，且当前线程数小于maximumPoolSize，会创建新的线程执行任务			如果工作队列已满，且当前线程数等于或大于maximumPoolSize，会执行拒绝策略
		
		JDK默认的工作队列有五种：

		ArrayBlockingQueue 数组型阻塞队列：
			数组结构，初始化时传入大小，有界，FIFO先进先出
			用一个重入锁，默认使用非公平锁，入队和出队共用一个锁，互斥。

		LinkedBlockingQueue 链表型阻塞队列：
			链表结构，默认初始化大小为Integer.MAX_VALUE，有界（近似无界），FIFO，			用两个重入锁分别控制元素的入队和出队，用Condition进行线程间的唤醒和等待。

		SynchronousQueue 同步队列：
			容量为0，添加任务必须等待取出任务，这个队列相当于通道，不存储元素。

		PriorityBlockingQueue 优先阻塞队列：
			无界，默认采用元素自然顺序升序排列。

		DelayQueue 延时队列：
			无界，元素有过期时间，过期的元素才能被取出。


	拒绝策略 (RejectedExecutionHandler)	拒绝任务的方案
		
		AbsortPolicy：		直接丢弃任务，抛出异常，这是默认的策略

		CallerRunsPolicy：	只用调用者所在的线程处理任务

		DiscardOldestPolicy:	丢弃等待队列中最早的任务，并执行当前任务
					尝试把这次拒绝的任务放入队列

		DiscardPolicy：		直接丢弃任务，也不抛出异常
		

除了上述四个核心参数外，线程池还有以下三个参数：

	空闲线程存活时间（keepAliveTime）：
		当线程池中的线程数量超过核心线程数时，多余的空闲线程在多长时间内没有执行任务后会被销毁；
时间单位（unit）：空闲线程存活时间的计量单位，如秒、毫秒等；
线程工厂（threadFactory）：用于创建新的线程，可以指定线程的名称、优先级、是否为守护线程等属性。