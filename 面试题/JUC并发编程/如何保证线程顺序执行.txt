线程顺序执行是指让多个线程按照一定的顺序来执行，而不是随机或者并发地执行。


线程顺序执行有时候是必要的，有些业务逻辑需要依赖于前一个线程的结果，或者需要保证输出的顺序性。


在Java中，有多种方法可以实现线程顺序执行，下面介绍四种常用的方法：



使用Thread类的join()方法
	
	join()方法可以让当前线程等待另一个线程执行完毕后再继续执行。

	例如，如果想让线程A、B、C按照顺序执行，
		可以在B线程中调用A.join()，在C线程中调用B.join()，
		这样可以保证A先执行，然后B再执行，最后C再执行。


使用单线程的线程池：

	线程池是一种管理多个线程的工具，可以控制线程的创建、运行和销毁。
	如果用一个只有一个线程的线程池，那么提交给这个线程池的任务就会按照提交的顺序来执行。

	例如，可以使用Executors类的newSingleThreadExecutor()方法来创建一个单线程的线程池，
	然后把线程A、B、C作为任务提交给这个线程池，就可以保证A先执行，然后B再执行，最后C再执行。


使用volatile关键字修饰的信号量：
	
	信号量是一种控制多个线程访问共享资源的机制，可以限制同时访问资源的线程数量。
	如果使用volatile关键字修饰的整型变量作为信号量，可以通过修改这个变量的值控制线程的执行顺序。

	例如，可以定义一个volatile int ticket = 1;作为信号量，
		然后让每个线程根据ticket的值来判断是否可以执行。

	例如，如果想让线程A、B、C按照顺序执行，
		可以让A线程在ticket等于1时才执行，且执行完后把ticket设为2；
		让B线程在ticket等于2时才执行，且执行完后把ticket设为3；
		让C线程在ticket等于3时才执行，并且执行完后把ticket设为1。
		这样就可以保证A先执行，然后B再执行，最后C再执行³。


使用Lock和Condition类：

	Lock提供了比synchronized更强大的锁机制的接口，可实现更细粒度的控制,灵活的响应中断和超时	Condition是与Lock配合使用的条件变量，可以让一个线程在满足某个条件时才继续执行，
		且可以精确地唤醒等待的线程。

	如果使用Lock和Condition类，那么就可以通过await()和signal()方法来控制线程的执行顺序。

	例如，如果想让线程A、B、C按照顺序执行，
	可以创建一个Lock对象和三个Condition对象，并且让每个Condition对象对应一个线程。
	然后让A线程获取锁后直接执行，执行完后唤醒B线程对应的Condition对象；
	让B线程在获取锁后等A线程对应的Condition对象，且被唤醒后执行，执行完唤醒C线程对应Condition
	让C线程在获取锁后等B线程对应的Condition对象，且被唤醒后执行，执行完唤醒A线程对应Condition
	这样就可以保证A先执行，然后B再执行，最后C再执行。
