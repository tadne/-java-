JVM 内存模型（JMM）:	描述 JVM 如何管理内存和线程之间如何进行通信的抽象规范，定义了一组规则，
			保证了不同线程对共享变量的操作可见性、有序性和原子性。

JMM 可以分为两个层次：运行时数据区域和内存屏障。

运行时数据区域:	 JVM 在运行时为程序分配的各种内存区域，它们包括以下几种：

  	程序计数器：	一块较小的内存空间，用于记录当前线程执行的字节码指令的地址，
			每个线程都有自己的程序计数器，因此它是线程私有的。

  	虚拟机栈：	一块用于存储局部变量表、操作数栈、动态链接、方法出口等信息的内存区域，
			每个方法在执行时都会创建一个栈帧，用于存储这些信息。
			每个线程都有自己的虚拟机栈，因此它是线程私有的。
   	
	本地方法栈：	一块用于支持本地方法执行的内存区域，本地方法是指使用其他语言编写的方法，
			通过 Java Native Interface（JNI）与 Java 代码交互。
			每个线程都有自己的本地方法栈，因此它是线程私有的。
   	
	堆：		一块用于存储对象实例和数组的内存区域，是所有线程共享的，
			也是垃圾回收器管理的主要区域。

			堆可细分为新生代和老年代，新生代可细分为伊甸园、幸存区from区和幸存区to，
			这些区域主要用于实现不同的垃圾回收算法。
   
	方法区：		用于存储已被虚拟机加载的类信息、常量、静态变量、编译后的代码等的内存区域，			它是所有线程共享的。
			方法区在 JDK 8 及以下版本中叫做永久代，
			在 JDK 9 及以上版本中叫做元空间，它们有不同的实现方式和特点。

		永久代:	用于存储已被虚拟机加载的类信息、常量、静态变量、编译后的代码等的内存区域，			是方法区（Method Area）的一种实现方式，也是所有线程共享的。
			特点:	回收效率很低，主要存储类元数据，类元数据的生命周期很长，很少被回收

		元空间:	用于存储类的元数据的内存区域，它取代了 JDK 8 及以下版本中的永久代。
			元空间不在虚拟机内存中，而是使用了本地内存，
			因此它的最大可分配空间为系统可用内存空间 。

		元空间和永久代有以下几个主要的区别：

			元空间不会受到固定大小的限制，永久代需要通过参数 -XX:PermSize 和 
				-XX:MaxPermSize 来设置大小，如果不设置，则默认为 64M。

			元空间可以动态地扩展或收缩，永久代只能在虚拟机启动时确定大小，
				不能在运行时改变。

			元空间可以根据不同的类加载器分配不同的空间，而永久代只有一个共享的空间。

			元空间可以避免永久代中常见的内存溢出问题，
			因为它可以使用更多的系统内存，而不会受到虚拟机内存的限制。

		元空间的引入是为了解决永久代的一些问题，如内存溢出、内存碎片、垃圾回收效率低等。
		但是，元空间也有一些潜在的风险，
		如可能导致本地内存不足、垃圾回收算法复杂、类卸载困难等。
				
	运行时常量池：	用于存储编译期生成的各种字面量和符号引用的内存区域，它是方法区的一部分，
			也是所有线程共享的。
			运行时常量池可在运行时动态地添加新的常量，如用 String 的 intern() 方法。
  	
	直接内存：	不属于虚拟机管理范围的内存区域，用本地方法通过NIO直接分配和访问系统内存，			从而提高 I/O 的性能。

内存屏障:	JVM 在生成指令序列时插入的一些特殊指令，用于实现内存屏障语义，
	即控制不同线程对共享变量的操作顺序和可见性。内存屏障分为以下四种类型：

   	LoadLoad 屏障：	用于保证 Load1 操作必须在 Load2 操作及其后续读操作之前执行的屏障，
			主要用于实现 volatile 变量的读语义。
   	
	StoreStore 屏障：用于保证 Store1 操作必须在 Store2 操作及其后续写操作之前执行的屏障，
			主要用于实现 volatile 变量的写语义。

	LoadStore 屏障：用于保证 Load 操作必须在 Store 操作及其后续写操作之前执行的屏障，
			主要用于实现 volatile 变量的读写语义。

 	StoreLoad 屏障：用于保证 Store 操作必须在 Load 操作及其后续读操作之前执行的屏障，
			主要用于实现 volatile 变量的写读语义。









