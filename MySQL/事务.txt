事务
	事务是一组操作的组合,不可分割的单位
	要么同时成功,要么同时失败


事务操作:
	查看事务提交方式		select @@autocommit;
	设置事务提交方式		set @@autocommit=0;//手动提交
	提交事务			commit;
	回滚事务			rollback;
	手动开启事务		start transaction  或  begin
	
四大特性:
	原子性:atomicity		:不可分割的最小操作单元,要么都成功要么都失败
	隔离性:consistency	:事务完成必须使所有时间保持一致
	一致性:isolation		:数据库系统提供隔离机制,保证事务不受外部并发影响独立运行
	持久性:durablity		:一旦提交或回滚,对数据库的改变是永久的

并发事务问题:
	脏读:		一个事务读到另一个事务还没提交的数据
	不可重复读:	一个事务先后读取同一条记录,两次数据不同
	幻读:		一个事务按条件查询,没有数据,但插入数据时,该数据已经存在

	脏读:		事务a执行更新还没提交的时候,事务b执行查询,导致b读到a还没提交的事务
	不可重复读:	事务a有两次读取,a读第一次,事务b修改,a再次查询得到的和第一次不同
	幻读:		事务a读取,事务b插入,事务a也插入,但是b已经插入.导致插入报错
				a再次读取,依然读不到,因为不可重复读被解决

事务的隔离级别:
	读未提交		read uncommitted	什么都不做
	读已提交		read commited		解决	脏读
	可重复读	(默认)	repeatable read		解决	脏读    不可重复读
	序列化		serializable		解决	脏读    不可重复的    幻读


	查看事务的隔离级别:	select @@trannsaction_isolation;
	设置事务的隔离级别:	set [session|global] transaction level [read uncommited|..]

	
	脏读:		别人还没提交,你就查,结果查到别人没有提交的事务.因为读未提交
	不可重复读:	你第一读,别人此时修改数据并提交,你再读,发现两次不一样
	幻读:		你第一次读,发现没有.然后此时别人插入数据,你这时也插入,发现重复报错
			你又读,发现还是没有,因为别人也没提交,导致你查不到(脏读)但是又插入不了




		