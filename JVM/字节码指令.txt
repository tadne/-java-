字节码指令
	

javap工具	

	javap -v HelloWorld.class  反编译命令

	当然,这个命令要先找的class文件

	
类加载
	
	原始java代码

	编译,得到字节码文件
	
	常量池载入运行时常量池
		但是一些 -128~127 不存在常量池中,而是和方法的字节码指令在一起
		java底层缓存了-128~127的整数

	方法的字节码指令载入方法区中

	main线程开始运行,分配栈帧内存
		栈帧内存:	局部变量表,操作数栈


案例:	分析a++
	psvm{	
		int a=10;
		int b=a++ + ++a + a--;
	}//10+12+12

	a++和++a的区别是执行iload还是先执行iinc,iinc命令是自增命令,iload是计算

	加载a=10到操作数栈
	改变局部变量表a=11
	改变局部变量表a=12
	相加10+12=22
	相加22+12=34
	改变局部变量表a=11
	b=34
	
案例:
	int x=10;
	while(true){
		x=x++;	
	}
			先加载x=10到操作数栈
			修改局部变量表x=11;
			再将操作数栈中的10赋值给x



	static int a=10;
	static{a=20;}
	static{a=30;}
			静态变量的赋值会被java收集为一个新的构造方法,原始构造方法被放在最后	
			<cinit>()V	收集static代码块和变量赋值的代码,初始化
		


	{b=20;}
	private int b=10;
	构造方法(int b){this.b=b;}
			局部变量同样会被收集为一个新的构造方法,原始构造方法会被放在最后
			<init>()V
	
	也就是说,会先执行直接赋值代码,后执行构造方法的代码
		
	例:
	    test(int b){
	        this.b=10;//后执行
	    }
    	int b=20;//先执行
    	public static void main(String[] args) {
    	    test t=new test(1);
    	    System.out.println(t.b);//10
    	}

方法调用
	构造方法和私有方法和静态方法是唯一确定的,是直接绑定的
	但是public普通方法是动态绑定的

		直接绑定（静态绑定/早期绑定）:
			编译时就确定调用哪个方法的过程，不需要考虑对象的实际类型，
			只根据对象的静态类型（即声明时的类型）来决定。
			直接绑定的方法通常是构造方法、私有方法和静态方法，
				这些方法不会被子类重写或覆盖，是唯一确定的。

		动态绑定（虚拟绑定/晚期绑定）:
			运行时根据对象实际类型来确定调用哪个方法的过程，需要考虑对象的多态性，
			即对象可能属于多个类的情况。
			动态绑定的方法通常是公有的非静态方法（也叫虚函数），
				这些方法可以被子类重写或覆盖，不是唯一确定的。

	对于静态方法的调用,是不需要对象调用的,在加载到操作数栈中时,会直接pop弹出
		

多态的原理
	执行invokevirtual指令调用方法时
		
	先通过栈帧中对象引用找到对象
	分析对象头,找到对象实际的class指令
	class结构中有虚方法表vtable,在类加载的链接阶段就已经根据方法的重写规则生成好了
	查表得到方法的具体地址
	执行方法的字节码

异常处理
	catch(Exception e)
		先加载e的异常信息
		底层有一个异常表,可以检查try中代码,一旦出现异常,就会执行catch
	multi-catch
		catch(NoSuchMethodException|IllegalAccessException  e)
		就多个异常存入同一个地方,入口相同
		底层有一个异常表,可以检查try中代码,一旦出现异常,就会执行catch
	finally
		加载字节码时,在try和catch后以及catch剩余的异常类型流程   都加载finally的字节码
			catch剩余的异常类型流程:	error..
		确保finally一定执行
		抛出异常
		不要在finally中return,因为这样会导致出现异常但是没有抛出
	
锁synchronized(方法内)
	加载锁对象
	在正常情况下,加载解锁字节码
	在异常表中,也加载解锁字节码
	保证在任何情况下,都加载解锁字节码















	