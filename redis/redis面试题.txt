Redis是什么?
	
	一个用C语言编写的,高性能的非关系型键值对数据库. 
	与传统数据库不同,Redis数据是存在内存中的,读写速度很快,广泛用于缓存方向
	Redis可以将数据写入磁盘,保证数据安全,并且Redis操作是原子性的

Redis优缺点

	优势:
		基于内存操作,		读写速度快
		支持多种数据类型:	String,Hash,List,Set,ZSet等
		支持持久化.		支持ROB和AOF两种持久化机制,持久化有效避免数据丢失问题
		支持事务. 		所有操作都是原子性的,同时Redis支持对几个操作合并后的原子性操作
		支持主从复制		主节点自动将数据同步到从节点,可以进行读写分离
		Redis命令单线程	Redis6引入多线程,但用于处理网络数据读写和协议解析,Redis命令执行依然单线程

	缺点:	
		对结构化查询支持较差
		数据库容量受到物理内存限制,不适合海量数据高性能读写,主要适用场景局限在较小数据量的操作
		Redis难支持在线扩容,在集群容量达到上限时,扩容很复杂


Redis为什么快?
	
	基于内存:		Redis使用内存储存,没有磁盘io开销.读写速度快
	IO多路复用:	Redis采用IO多路复用技术.用单线程轮询描述符,将数据库操作转换成事件,不在网络上浪费时间
	高效数据结构:	Redis每种数据类型在底层都做了优化,目的是追求更快速度
	
为什么不使用Redis做主数据库,只用它做缓存
	
	事务处理:		Redis只支持简单的事务处理,对于复杂的事务无能为力,如跨多个键的事务处理
	数据持久化:	Redis是内存数据库,数据存在内存中,有安全问题.虽然有持久化机制,但有些限制
	数据处理:		只支持一些简单数据结构,如字符串,列表,哈希表等,如果要处理复杂数据结构,如mysql中的表
				就很不方便
	数据安全:		Redis没有提供像主数据库那样的安全机制,如用户认证,访问控制等
	

Redis的线程模型:	
		
	基于Reactor模式开发了网络事件处理器,这个处理器被称为文件时间处理器.
		组成结构为4部分:多个套接字,IO多路复用,文件事件分配器,事件处理器,
		因为文件事件分配器队列的消费是单线程的,所以Redis才叫单线程模型
			文件事件处理器
				用IO多路复用同时监听多个套接字,根据套接字目前执行的任务为套接字关联不同事件处理器
				被监听的套接字准备好执行连接accept,read,write.close等操作时,对应事件发生,
				然后文件事件处理器会调用套接字关联的事件处理器处理时间
	虽然文件处理器以单线程运行,但IO多路复用监听多个套接字,文件事件处理器既实现了高性能网络通信,
	又很好的与Redis服务器中其他同样以单线程方式运行的模块对接,保持了Redis内部单线程设计的简单性


Redis应用场景
	
	缓存热点数据,	缓解数据库压力
	Redis原子性的自增操作可以实现计数器功能,		如统计用户点赞数
	分布式锁.			在分布式场景下,无法使用单机环境下的锁来对多个节点进程进行同步.
					Redis自带的SETNX实现分布式锁,除此之外,用官方提供的RedLock分布式锁实现
	简单的消息队列	redis自身的发布订阅模式或List实现简单的消息队列,实现异步操作
	限速器			限制某个用户访问接口的频率,如秒杀场景防止快速点击带来的压力
	好友关系			利用集合中的命令如: 交集,并集差集等实现共同好友,共同爱好等功能	

Memcached和Redis的区别
	
	Memcached 数据结构单一,只用来缓存数据,而Redis支持多种数据类型
	Memcached 不支持持久化,重启数据消失,Redis支持持久化
	Redis提供主从同步和cluster集群,能提供高可用服务.
	Redis速度比Memcached 快很多
	Redis用单线程IO多路复用,Memcached使用多线程非阻塞式IO
	value值大小不同,Redis最大位512m,Memcached只有1m



为什么要用 Redis 而不用 map/guava 做缓存?

	自带map是本地缓存,特点是轻量快速,生命周期随着jvm销毁销毁,
			多实例的情况下,每个实例都要各自保存一份缓存,缓存没有一致性

	用redis称为分布式缓存,多实例的情况下,各个实例共用一份缓存,有一致性
	

Redis数据类型
	
	String :		值可以是字符串,数字,或二进制.但是要求值不能超过512m
	Hash:		hash是一个键值对集合
	Set:			无序去重的集合,提供了交集并集等方法
	List:			有序可重复集合,底层依赖双向链表实现
	SortedSet:	有序Set.底层维护了Score的参数实现,适用于排行榜和带权重的消息队列等场景

	Bitmap:		位图,以位为单位数组,数组中的每个单元只能存0或1,数组的下标在Bitmap中叫偏移量
				BitMap的长度和集合中元素的个数无关,与基数额的上限有关
	Hyperloglog:	用来做基数统计的算法,
					优点:	在输入元素的数量或体积非常大时,计算基数所需的空间是固定且很小
					场景:	统计独立访客
	Geospatial:	用于储存地理地址信息,并对储存的信息进行操作,适用场景如定位,附近的人等



SortedSet和LIst异同点?
	
	相同:
		有序
		可以获得某个范围内的元素

	不同:
		LIst基于链表实现,获取两端元素速度快,访问中间元素速度慢
		SortedSet基于散列表和跳跃表实现,访问中间元素时间复杂度是OlogN
		LIst不能简单调整某个元素位置,SortedSet可以
		SortedSet更耗内存

Redis内存用完会怎样?
	
	如果达到设置上限,Redis写命令会返回错误信息,读命令正常
	也可以配置内存淘汰机制,当内存达到上限覆盖旧内容

Redis如何内存优化
	
	利用Hash,list,sortedSet,Set等集合,通常情况下小的键值对结构数据可以更紧凑的存放.
	尽可能使用hashes,散列表使用的内存比较小.,应该尽可能的将你的数据模型抽象到一个散列表里.
		举例:	web系统中有一个用户对象,不要为这个用户的名称,姓氏等设置单独key,
				而是将用户的所有信息存在一张散列表中

keys命令存在的问题
	
	redis是单线程的,keys指令会导致线程阻塞,直到执行完毕服务才恢复.
		scan采用渐进式遍历的方式解决keys命令带来的阻塞问题,每次scan的时间复杂度是O(1),
			但要实现keys功能,要多次使用scan

	scan缺点:	scan过程中如果有键发送变化,
				遍历过程会遇到以下问题: 新的键可能没有遍历,遍历出重复的键等
				也就是说,不能保证完整遍历所有的键


Redis事务
	
	原理:	将一个事务范围内的若干命令发送给Redis,再让redis依次执行
	事务生命周期:
		MUITI命令
			MULTI命令开启事务
			开启事务的时候,每次操作的命令将会被插入到一个队列中,同时这个命令不会被真的执行
			EXEC命令提交事务

			其中一个事务范围内某个命令出错不会影响其他命令的执行,不保证原子性
	
		WATCH命令
			可以监控一个或多个键,一旦一个键被修改,之后的一个事务就不会执行,EXEC命令取消监控
			也可以使用UNWATCH来关闭监控

	
			
Redis事务支持隔离性吗?

	Redis是单线程的,且保证在执行事务时,不会对事务中断,
		事务可以运行直到执行完所有队列中命令为止,因此,Redis的事务带有隔离性
	

Redis事务保证原子性吗?支持回滚吗?

	Redis单条命令式原子性的,但是事务不保证原子性,并且没有回滚.
	事务中任意命令执行失败,其余命令仍执行

持久化机制
	
	持久化就是将内存中数据写到磁盘中,防止数据丢失
	支持两种持久化,
		RDB方式:依据指定规则定时将数据写入磁盘
			Redis默认的持久化方案,开启后会将内存数据写入磁盘,在指目录中生成dump.rdb文件
			Redis重启会加载该文件恢复数据
				bgsave是主流的出发RDB持久化的方式,
					执行过程如下:
						BGSAVE命令
						Redis父进程判断当前是否存在正在执行的子进程,如果存在,BGSAVE命令直接返回
						父进程执行fork操作创建子进程,fork操作过程中父进程会阻塞
						当子进程写完所有数据后会用该临时文件替换旧RDB文件	

				一旦Redis异常会读取RDB文件,这样如果Redis异常会丢失最后一次持久化后的数据更改

			触发RDB的方式:
				手动:	执行save或bgsave命令.
						save执行快照过程会阻塞
						bgsave可以再后台异步执行
				自动:	按照配置规则,如save 100 10,即100秒内10个键被修改了
						如果从节点执行全量复制操作,主节点会自动执行bgsave生成RDB文件发送给从节点
						默认情况下执行shutdown命令时,如果没有开启AOF则自动执行bgsave

			优点:	加载RDB文件速度比AOF快的多
					单独使用子进程持久化,主进程不会进行IO,保证高性能
			缺点:	RDB不能做到实时持久化,因为bgsave运行要执行fork创建子进程,执行成本高
					RDB文件用特殊二进制保存,不同版本Redis的RDB文件可能不兼容

		AOF方式持久化
			以独立日志方式记录每次写命令,Redis重启时重新执行AOF文件中的命令达到恢复数据目的
			主要作用:		解决了数据持久化的实时性
			默认情况下Redis不开启AOF,可以用appendonly参数启用:  appendonly yes 
				开启后每次执行写命令,Redis将命令写入aof_buf缓冲区,缓冲区按对应策略向硬盘同步操作
				
			默认情况下每30秒一次同步,防止缓冲区数据丢失.
				可在Redis写入AOF文件后主动要求系统同步缓冲区,可以用appendfsync参数设置同步时机

			执行流程:
					    append		  sync 		     load
				命令写入 ==>  AOF缓存  ==>  AOF文件  <==  重启
	
				写入命令追加到AOF缓存区
				AOF缓冲区按照对应策略向硬盘同步
				AOF文件越来越大,要定期对AOF文件重写压缩体积. 重写: 就是写命令同步到新AOF文件中
				Redis服务器重启时,可以加载AOF文件数据恢复

			优点:  更好保存数据,可以调为每秒1次fsync操作,最多丢失1秒数据
				  以append-only模式写入,没有磁盘开销,写入性能好

			缺点: 对同一份AOF文件比RDB文件大的多
				 数据恢复慢
				
如何选择两种持久化方式?
		
	通常,两种同时使用保证数据安全
		如果数据不重要可以不开启持久化
		如果数据重要,但可以支持分钟级别数据丢失,只需RDB即可
		如果做内存数据,要用Redis持久化,建议两个一起使用
		如果只用AOF,优先使用everysec的配置选择,因为在可靠性和性能上取了平衡

		当两个都开启时,Redis优先使用AOF恢复数据,因为AOF数据更完整


Redis有哪些部署方案?
	
	单机:	能承载QPS在上万到几万不等.  内存容量有限,处理能力有限,无法高可用
	主从:	一主多从,		主负责写并将数据复制到slave节点,
						从负责读.
						实现水平扩容,支持读高并发,主节点挂了可以手动更新.可用性低.很少使用
	
	哨兵:	主从复制不能自动故障转移,不能高可用.
			哨兵可以自动切换主从节点,主节点挂了自动选举新主节点
			
			可用性好,但是每个节点数据一致,浪费空间.集群不大并且需要自动容错的时候使用

	Redisclust: 
			服务器分片技术,3.0版本提供.不使用一致性hash,而是使用slot槽概念.
			一共分为16384个槽位,将请求发到任意节点,接受到请求的节点将请求发到正确节点执行
			针对海量数据+高并发+高可用场景.数据量很多比较推荐这种,各个节点容量总和就是其容量



主从架构
	一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。
	所有的读请求全部走从节点。很轻松实现水平扩容，支撑读高并发。

	复制功能支持多个数据库之间的数据同步。
		主数据库可以进行读写操作，当主数据库的数据发生变化时会自动将数据同步到从数据库。
		从数据库只读的，会接收主数据库同步过来的数据。
		一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。

	主从原理:
		启动从节点时,发送一个psync命令给主节点
		如果从节点初次连接,触发全量复制,主节点开启后台线程,生成RDB快照
		接下来将客户端新收的写命令缓存到内存中
		RDB文件生成完发给从节点.从节点将RDB写入磁盘并加载到内存
		主节点再将内存中缓存的写命令发送给从节点,从节点同步数据
		如果从节点网络故障端口,会自动从重连,重连后主节点只会将部分缺失的数据同步给从节点


哨兵
	主从不能故障转移达到高可用,哨兵可以自动切换主从节点
	
	流程
		客户端连接Redis时,先连接哨兵,哨兵告诉客户端Redis地址,客户端再连接对应Redis
		主节点宕机时,哨兵监控到主节点宕机.就重新选举一个表现较好的从节点作为主节点.
		再通过发布订阅模式告知所有从节点切换主机

	原理:
		每个哨兵按照每秒一次的评论给主从节点发ping请求
		如果最后一次有效回复超出指定值,这个实例就会被sentinel标记为主观下线
		如果主节点被标记,那么监视这个主节点的所有sentinel要每秒一次去确认是否真的下线
			有足够数量的sentinel在足够时间确认主观下线,那么就标记该实例客观下线
			没有足够数量标记,那么就移除主观下线状态
		哨兵节点选举哨兵leader,负责故障转移
		哨兵leader负责选举从节点作为新主节点,并通知其他从节点更新主节点

RedisCluster
	哨兵解决了主从故障转移,达到高可用.但是主节点的写能力和容量受限.
	Cluster模式实现了分布式存储,每个节点存储不同内容,解决主节点写能力,容量受限问题
	
	RedisCluster集群节点最少为6个节点以上,3主3从.主节点提供读写,从节点备用不提供请求,作为故障转移使用

	采用了虚拟槽位分区,所有键按照哈希函数映射到0~16383个槽位.每个节点维护一部分槽位以及槽位键值数据
	
	原理:
		通过哈希,将数据分片,每个节点存一定槽位区间数据.默认分配16383个槽位
		每份数据分片存在多个互为主从的多节点上
		数据写入先写主节点,再同步从节点(支持配置为阻塞同步)
		同一分片多节点间数据不保持一致
		读取数据时,客户端操作的key分配在该节点上时,reds会返回转向指令,指向正确节点
		扩容时要把旧节点数据迁移部分到新节点
		
	在这个架构下,每个redis要开放两个端口,6379和16379
		16379端口用来进行节点间通信,叫做ClusterBus.用来进行故障检测,配置更新和故障转移授权
		ClusterBus使用了gossip二进制协议.用来节点间高效数据交换,占用更少网络和处理时间

	优点:	无中心架构,支持动态扩容
			数据按照槽位存在多节点,节点间数据共享,可动态调整数据分布
			高可用.部分节点不可用时,集群可用.集群实现自动故障转移

	缺点:	不支持批量操作
			数据异步复制,不保证强一致性
			事务操作有限支持,多个key在一个节点事务支持,但是多个key在多个节点操作不支持事务
			不支持多数据库空间,单机下可以支持16个数据库,集群下只支持0号数据库


哈希分区算法有哪些?
	节点取余分区		用特定数据,如Redis的键或用户ID,对节点数量取余,来决定数据映射
	一致性哈希分区	为每个节点分配一个token,范围在0~232.这些token构成哈希环
					数据读写执行节点查找操作时,先按key计算hash,
					再顺时针找一个大于等于该哈希值的token节点
					相比于节点取余好处在于加入和删除只影响哈希环中相邻的节点,对其他节点无影响
	虚拟槽分区		键按照哈希函数映射到0~16383整数槽中,slot=CRC16(key)&16383
					每个节点负责一部分槽以及槽映射的键值数据



过期键的删除策略
	被动删除:			访问key时,发现过期,那就删除
	主动删除:			定时清理key,每次清理遍历所有DB,随机取出20个key,过期就删除,
					如果其中有5个过期,那就继续对该DB清理	
	内存不足时清理:	redis有最大内存限制,如果超过设定值就按照配置的淘汰策略清理内存

内存淘汰策略有哪些?
	Redis内存超过最大许可内存后,触发内存淘汰策略.删除一些不常用数据,保证Redis运行
		4.0提供策略
			volatile-LRU:  删除最远使用的key
			allkeys-LRU:	内存不足时,移除最少使用的key
			ttl:			从设置过期时间的数据集合中删除将要过期的
			v-random:	从设置过期时间的数据集合中随机删除
			a-random:	所有数据中随机删除
			no-eviction:	禁止删除数据
		4.0之后提供
			v-lfu	:		从设置过期时间数据中删除最少使用的
			a-lfu:		内存不足时,所有数据中删除最少使用的

	内存淘汰策略可以通过配置文件来修改，相应的配置项是maxmemory-policy，默认配置是noeviction。




如何保证缓存和数据库双写时的数据一致性
	1:	先删除缓存再更新数据库

		问题: 删除缓存后,更新数据库之前,有新的请求到来会导致数据库旧数据被写入缓存
	
	2:	先更新数据库再删除缓存
		
		问题:更新数据库和删除缓存期间,读取的还是缓存旧数据.但是影响相对更小
	
	3:	异步更新缓存
		
		更新完成后不操作缓存,而是搞到消息队列中,再让Redis自己消费更新数据.
		保证数据操作顺序一致性,确保缓存数据正常
		
		
缓存穿透
	查询数据库不存在的数据,导致查不到缓存,数据库压力变大
	
	解决:	1:缓存空值
			2:布隆过滤器, 将可能存在的数据哈希到足够大的bitmap中查询不存在的数据会被bitmap拦截

缓存雪崩
	设置缓存时过期时间相同,导致缓存同一时间失效.数据库压力变大
	
	解决:	1:再原来失效时间基础上加随机值,让过期时间分散
			2:加锁排队保证缓冲,防止大量请求同时操作数据库.但是增加了响应时间,降低了吞吐量
			3:设置二级缓存.二级缓存就是除了Redis缓存,再设置一层缓存,Redis失效后,先查询二级缓存

缓存击穿
	大量请求同时访问一个key,该key失效导致数据库压力变大

	解决:	1: 互斥锁,并发请求只有一个线程拿到锁并查询数据库
			2:热点数据不过期.再异步定时任务加载数据更新缓存.流量特别特别大的场景使用.
				使用时要考虑业务能接受数据不一致的时间.还要考虑异常情况的处理,保证缓存定时刷新
			
缓存预热
	就是系统上线后,将缓存数据加载到缓存系统,避免客户直接查询数据库
	
	方案:	1写个缓存刷新页面,上线时手动操作
			2数据量不大,项目启动时自动加载
			3定时刷新缓存

缓存降级
	访问剧增,服务出错或非核心服务影响核心服务时,仍要保证服务可用.就可以使用降级策略
		可以根据关键数据自动降级,也可以配置人工降级

	缓存降级目的: 保证核心服务可用.
	
	要对系统梳理,哪些服务可以降级丢弃,哪些服务必要..
	
	降级的目的是防止Redis服务故障,导致数据库一起雪崩.所以,对于不重要的缓存数据,可以采用服务降级策略
		例如:	Redis出错,不查数据库,而是返回默认值


Redis实现消息队列

	用list存储数据信息,rpush生产消息,lpop消费消息.
		当lpop没有消息时,可以sleep一段时间.也可以用blpop没有消息时阻塞
		
	使用pub/sub实现生产者消费者模型.缺点: 消费者下线时,生产的消息会丢失


Redis实现延时队列
	
	用sortedset,用时间戳当score,消息内容为key,
			生产者调用zadd生产消息,
			消费者用zrangebyscore获取n秒前的数据轮询处理	

pipeline作用

	redis执行命令流程:		发送命令,命令排队,命令执行,返回结果.
			用pipeline可以批量请求,批量返回结果,执行速度更快

	但是pipeline的命令一次不能太多,不然数据量太大会导致客户端等待,还可以网络阻塞

	原生批处理命令(mset和mget)与pipeline对比
		原生命令式原子性的,pipeline非原子性.pipeline不会回滚
		原生命令只有一个命令,pipeline支持多命令


LUA脚本
	
	Redis通过LUA脚本创建有原子性的命令
		
	执行LUA脚本的方法:	eval和evalsha.eval命令使用内置lua解释器

	lua脚本作用:  
			原子性执行,中间不会插入其他命令
			可以将多条命令一次性打包,减少网络开销
	

什么是RedLock
	
	Redis官方给出的基于Redis实现分布式锁的名称.
		实现了:	
			安全:  		互斥访问,只有一个客户端拿到锁
			避免死锁:		客户端最终都可能拿到锁,即使原本锁住资源的客户端挂了也没问题
			容错:		只要大部分Redis节点存活就正常服务

Redis大数据key怎么处理

	当val大于5mb,或者集合类型成员超过1万个的key叫做大key

	处理:	string类型:  	可以使用序列化或算法控制大小.或者将key拆分,再用multiget实现事务读取
			集合类型:		进行数据分片
		

redis场景性能问题和解决

	存在bigkey。
		Redis中存了 大key，那在淘汰删除 大key 释放内存时，也会耗时较久。
		应避免存储 大key，降低释放内存的耗时。

	Redis 设置了内存上限 maxmemory，可能导致 Redis 变慢。
		Redis 内存达到 maxmemory 后，每次写入新的数据前，Redis 必须先从剔除部分数据，
		让实例的内存维持在 maxmemory 之下，然后才能把新数据写进来。

	开启了内存大页。
		Redis 执行后台 RDB 和 AOF rewrite 时，用 fork 子进程方式来处理。
		但主进程 fork 子进程后，主进程依可接收写请求，此时的写请求用 CopyOnWrite方式操作内存数据。

		写时复制？

			好处:	父进程任何写操作，并不会影响子进程的数据持久化。
			
			缺点:	但主进程拷贝内存数据时，涉及到新内存的申请，如果此时操作系统开启了内存大页，
					那此时，客户端即便只修改 10B 数据，Redis 申请内存时也会以 2m 为单位申请，
					申请内存耗时变长，导致每个写请求的延迟增加，影响到 Redis 性能。


	使用了Swap。
		操作系统为缓解内存不足对应用程序的影响，允许一部分内存中的数据换到磁盘上，达到应用程序
		对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是 Swap。
		
		内存中的数据被换到磁盘上后，Redis 访问这些数据要从磁盘上读取，访问磁盘的速度很慢。
		这个操作延时是无法接受的。
		
		解决方案:		增加机器内存，让 Redis 有足够内存。

	网络带宽过载。
		网络带宽过载情况下，服务器在 TCP 层和网络层会出现数据包发送延迟、丢包。
		Redis 的高性能，除了操作内存，就在于网络 IO ，如果网络 IO 存在瓶颈，那也会严重影响 Redis 性能
	

	频繁短连接。
		频繁的短连接导致 Redis 大量时间耗在连接建立和释放上，
		TCP 的三次握手和四次挥手也会增加访问延迟。
	
		应用应该使用长连接操作 Redis，避免频繁的短连接。
	
为什么 Redis 集群的最大槽数是 16384 个？
	
	Redis Cluste 采用数据分片，定义了16384个槽，集群中每个Redis负责维护部分槽及槽所映射的键值数据。


	Redis每个节点间会定期发送ping/pong消息交换数据信息。


	Redis集群的节点会按照以下规则发ping消息：
		(1)每秒随机选取5个节点，找出最久没有通信的节点发送ping
		(2)每100毫秒扫描本地节点列表，如果节点最近一次接受pong的时间大于cluster-node-timeout/2 
				则立刻发送ping消息
		
		心跳包的消息头里有个myslots的char数组，是一个bitmap，每一个位代表一个槽，如果该位为1，
		表示槽是属于这个节点的。

	为什么 Redis 集群的最大槽数是 16384 个，而不是65536 个?

		1、如果采用 16384 个插槽，那心跳包的消息头占用空间 2k ；太大浪费带宽。
		2、一般一个Redis集群不会有超过1000个master节点，太多可能网络拥堵。
		3、哈希槽通过一张bitmap的形式保存的，传输时会对bitmap压缩。
			bitmap的填充率越低，压缩率越高。其中bitmap 填充率 = slots / N (N表示节点数)。
			所以，插槽数越低， 填充率会降低，压缩率会提高。



