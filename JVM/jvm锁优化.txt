synchronized优化:	jvm中,每个对象都有对象头(包含class指针和Mark Word)
			MarkWord平时存对象的hash码,分代年龄.
			加锁时,这个信息就根据情况即替换为标记位,线程锁记录指针,重量级指针,线程id等

	轻量级锁:	优化 Java 性能的技术，指在没有多线程竞争的情况下，
			用一些简单的操作代替传统的重量级锁，减少锁的开销，提高程序的执行效率。

		锁记录:	每一个线程的栈帧中都会包含一个锁记录的结构,内部可以存锁定对象的 MarkWord
		
无竞争情况:
		原理:	一个线程尝试获取一个对象的锁时，
			那该线程会将对象头中的MarkWord复制到自己的栈帧锁记录中，
			检查对象锁的状态,如果MarkWord为01则无锁,
			并将对象头中的标记字段指向自己的栈帧，完成锁的获取。
			没有锁竞争时不需要使用操作系统的同步工具，也不会线程阻塞，因此效率较高。

			

		锁重入:  	指当一个线程已经获取到一个对象的锁时，可以再次获取该对象的锁，
			而不会导致死锁或异常。
			锁重入可以保证线程在执行同步代码时的一致性和安全性。


	
		如果一个对象虽然有多线程访问,但是多线程访问时间是错开的,那么可以使用轻量级锁来优化
		
		
		在某一锁竞争的时候,可以正常加锁成功,效率高.
		但有剧烈锁竞争的时候,会导致锁对象被其他线程持有时,要不断执行锁重入,消耗性能

有锁竞争情况
		锁膨胀:	如果有另一个线程尝试获取同一个对象的锁，
			会发现对象头中的标记字段已经指向了其他线程的栈帧，
			那它就会尝试使用 CAS操作来修改对象头中的标记字段，
			如果成功，就说明该线程获取到了锁；
			如果失败了，就说明有多线程竞争，
			那么轻量级锁就会膨胀为重量级锁，使用操作系统的同步工具来进行同步控制。

	monitor
		monitor是一个同步工具，内置在每一个对象中，任何一个对象都有一个monitor与之关联。
		synchronized在JVM里的实现就是基于进入和退出monitor实现的，
		底层是通过成对的monitorenter和monitorexit指令来实现。

		monitorenter：
			如果当前monitor的进入数为0时，线程就会进入monitor，并且把进入数+1，
				那么该线程就是monitor的拥有者。
			如果该线程已经是monitor的拥有者，又重新进入，就会把进入数再次+1。
			也就是可重入的。
		monitorexit：
			执行monitorexit的线程必须是monitor的拥有者，
			指令执行后，monitor的进入数减1，
			如果减1后进入数为0，则该线程会退出monitor。
			其他被阻塞的线程就可以尝试去获取monitor的所有权。

	当多个线程同时访问同步代码块时，
	首先会进入到EntryList中，通过CAS的方式尝试将Monitor中的owner字段设置为当前线程，
	同时count加1，若发现之前的owner的值就是指向当前线程的，recursions也要加1。
	如果CAS尝试获取锁失败，则进入到EntryList中。
	当获取锁的线程调用wait()方法，则会将owner设置为null，同时count减1，recursions减1，
	当前线程加入到WaitSet中，等待被唤醒。
	当前线程执行完同步代码块时，则会释放锁，count减1，recursions减1。
	当recursions的值为0时，说明线程已经释放了锁。


重量级锁(jdk6后的优化):
	
	自旋:		在获取锁失败后,不会让锁阻塞,去自旋
			自旋就是不停重试获取锁
			在重试多次后放弃重试


	jdk6自旋锁是自适应的:
		如果一个对象刚刚自旋成功了,那就会多自旋几次,反之就少自旋几次或者不自旋

		自旋会占用cpu时间,单核cpu自旋是浪费的,多核会有优势



偏向锁:		轻量级锁在某一竞争时,每次重入仍然要执行CAS操作,
	
	jdk6中引入了偏向锁来进一步优化,
		只有第一次使用CAS将线程ID设置到对象的MarkWord头,
		之后发现这个线程id是自己的就是没有竞争,不用重新CAS

		撤销偏向需要将持锁线程升级为轻量级锁,这个过程要STW(Stop The Word)
		访问对象的hashCode也会撤销偏向锁
		如果对象虽然被多个线程访问,但是没有锁竞争,这时偏向线程1的对象也还有机会偏向线程2.
			重偏向会重置对象的线程id
		撤销偏向和重偏向都是批量进行的,以类为单位
		如果撤销偏向到达某个阈值,整个类的所有对象都会变成不可偏向的
		可以主动使用-XX:-UseBiasedLocking禁用偏向锁


其他优化:	减少上锁时间:	即同步代码块中尽量短

		减少锁的粒度:	将一个锁拆分为多个锁来提高并发

				如:	LinkedBlockingQueue入队和出队使用不同锁,效率更高


		锁粗化:		多次循环进入同步代码块不如同步代码块内循环

				如:	jvm在用StringBuffer调用append时,
					可能将多次append粗化为一次,
					因为都是同一对象加锁,不用多次重入


		锁消除:		jvm用逃逸分析,当某个加锁对象时方法局部变量时,不会被其他线程访问				这时会被即使编译器忽略同步操作	

		读写分离:	CopyOnWriteArrayList
				CopyOnWriteSet	
