
volatile
		保证一个线程对这个变量的修改，另外一个线程立马可以看到



JMM(Java Memory Model):		Java内存模型:    JVM规范中所定义的一种内存模型。

		描述了Java程序中各种变量(线程共享变量)的访问规则，
			以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。

特点：

		所有共享变量都存储于主内存(计算机的RAM)这里的变量指的是实例变量和类变量。
		不包含局部变量，因为局部变量是线程私有的，不存在竞争问题。

		每一个线程都有自己的工作内存，线程的工作内存保留了线程使用过的变量的副本。

		线程对变量所有的操作(读，写)都必须在工作内存中完成，不能直接读写主内存中的变量，
		不同线程间不能直接访问对方工作内存的变量，线程间变量的值的传递要通过主内存完成。

	一般工作流程
		从主内存中读取数据到工作内存
		对工作内存中的数据进行操作
		将工作内存中的数据写回主内存

	
	但在出现子线程变量要修改,主线程要用到子线程变量时,要小心内存更新不及时的问题


解决方案:	1:	锁,在主线程类中给 出问题的 方法上锁
		2:	volatile关键字来修饰问题变量
		
		原理:	volatile关键字保证不同线程对共享变量操作的可见性
			也就是当线程修改了volatile修饰的变量并写回主内存时，其他线程立即看到最新的值。


	volatile可见性实现原理
		对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存。
		写操作会导致其他线程中的缓存无效，让其他线程无法使用缓存，只能从主内存中获取
		实现了线程的可见性。


	volatile与synchronized的区别：

		volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。

		volatile保证数据可见性，但不保证原子性(多线程进行写操作，不保证线程安全);
		synchronized是一种排他（互斥）机制,
			synchronized修饰的代码块，被修饰的代码块称之为同步代码块，
			无法被中断可以保证原子性，也可以间接的保证可见性。


	原子性举例:   线程A和线程B在代码层面对变量a=100进行自增操作

		线程A要对变量进行自增1的操作，先要从主内存中读取变量count的值。
		由于CPU的切换关系，CPU执行权切换到了B线程。A就绪，B运行。
		B也从主内存中读取count变量的值,由于A没有对count值做修改,故B读取的还是100
		B工作内存中对变量执行+1操作，但是未刷新到主内存中
		此时CPU的执行权切换到了A，此时B没有将工作内存中的数据刷新到主内存，
		故A工作内存中的变量值还是100，没有失效。A对工作内存中的数据进行了+1操作。
		线程B将101写入到主内存
		线程A将101写入到主内存
		导致数据一致性被破坏

		其实就是每次从主内存读数据和写数据都要重新抢夺cpu导致的


	





















