# TCP连接建立

## TCP三次握手过程

TCP是面向连接的协议，使用前必须先建立连接

- 一开始，客户端服务端都是close状态，服务端先监听对应端口，处于listen状态
- 客户端**随机初始序列号（`client_isn`）**，将SYN字段置于1，发送给服务端，客户端进入SYN-SENT状态
- 服务端收到客户端SYN报文，服务端**随机初始序列号（`server_isn`）**，**将client_isn+1置于确认应答号，将SYN、ACK置于1**，发给客户端，客户端进入SYN-RCVD状态
- 客户端收到后，响应报文：**SYN、ACK置于1，确认应答号填入server_isn+1**，发给服务器。客户端进入ESTABLISHED状态
- 服务器收到，进入ESTABLISHED状态

## 如何在Linux中查看TCP状态

netstat -napt 命令

## 为什么是三次握手？

**TCP连接**：用于保证可靠性、流量控制维护的某些状态信息，这些信息包括**Socket、序列号、窗口大小**，称为连接

为什么三次握手才可以初始化Socket、序列号、窗口大小？

- 三次握手才能阻止历史连接的初始化
- 三次握手才能同步双方序列号
- 三次握手才能避免资源浪费

### 避免历史连接

三次握手的首要原因就是要避免历史连接

场景： 客户端发送SYN报文，但是报文网络阻塞了，客户端又重新发送了报文

三次握手解决该问题：

- 旧报文比新报文早到达服务端，此时服务端回复SYN+ACK报文给客户端，并填入确认号
- 客户端收到后，发现和期望收到的新报文的确认号不一致，于是回复RST报文
- 服务端收到RST报文，释放连接
- 后续新报文到达服务端，客户端与服务端就正常三次握手了

如果是两次连接，就无法阻止历史连接了，因为**服务端没有中间状态给客户端阻止历史连接**。

- 如果是两次握手，那服务端在收到SYN后，直接进入ESTABLISHED状态，这时就可以给对方发数据了，但客户端没有进入ESTABLISHED。如果这次是历史连接，那就会回复RST报文断开，这就导致资源的浪费，浪费了连接还传输了数据
- 这种情况的解决**一定要在服务端发送数据之前，所以TCP三次握手的最主要原因是防止历史连接**

### 同步双方初始序列号

TCP的通信双方必须维护一个序列号，序列号是可靠传输的关键因素，作用是：

- 接收放可以去除重复数据
- 接收放可以根据数据包的序列化按序接收
- 可以标识发送的数据包中，哪些是已经被对方收到的

当客户端携带序列号的SYN报文时，要服务端返回ACK。当服务端发送SYN报文的时候，也要客户端ACK。一来一回才能确保双方序列号被可靠同步

### 资源浪费

两次握手的情况下，当客户端SYN报文阻塞了，客户端没有收到ACK就会重发SYN，由于**没有第三次握手，服务端不知道客户端是否ACK，所以服务端每收到一个SYN都只能主动建立一个连接。**

小结：三次握手能防止历史连接的建立，减少双方不必要资源开销，帮助同步序列号。


## 每次TCP的序列号不一致

不一致原因：

- 历史报文被下一个相同的四元组连接接收（主要因素）
- 防止黑客伪造相同序列号TCP报文接收

假设每次建立连接序列号都是从0开始，那么

- 客户端和服务端建立TCP，客户端发数据包的时候阻塞了，服务端宕机重启了，那之前的链接就消失了，客户端收到数据包时发送RST报文
- 接着客户端又和服务器建立和上次四元组一致的链接
- 新连接完成后，上一个链接数据包到了，这就导致数据错乱

**如果每次建立连接，客户端和服务端初始化序列化一样，很容易出现历史报文被下一个四元组的链接接收的问题**


## 初始序列号ISN是如何随机产生的

基于时钟产生，每4微秒+1。转一圈4.55小时。RFC793提到初始化序列号ISN随机生成算法 ISN=M+F

- M:计时器，每4微秒+1
- F：Hash算法，根据四元组生成的随机数

随机数是基于时钟递增的，生成一样的初始化序列号的概率很低


## IP层分片，为什么TCP还要MSS？

- MTU：一个网络包的最大长度，以太网1500字节
- MSS：除了IP和TCP，一个网络包能容纳的TCP数据的最大长度

如果TCP报文交给IP分片有什么异常？

IP层有一个超过MTU的数据发送，那么IP就要分片保证每片小于MTU。把IP数据分片后，由目标主机IP重新组装，再交给上层TCP。

但是**如果有一个IP分片丢包了，那整个IP报文所有分片都要重传**。因为IP层没有超时重传机制，由TCP负责超时和重传。如果IP分片丢失，接收放IP层就不能组装成完整TCP头，导致数据无法发给TCP层，导致收不到ACK，开始超时重传

为了达到最佳效能，TCP协议在**建立连接时就要协商双方MSS值。数据超过MSS，TCP就会进行分片。而且TCP丢包重发也是MSS为单位，而不是MTU。

## 第一次握手丢包

客户端发送SYN包，如果丢包，客户端收不到ACK，会触发超时重传，并且**重传的SYN报文序列号是一样的**

超时时间在不同系统中默认不同，这是内核参数，改起来很烦。

通常每次超时是上一次的二倍，并且默认为5次，超过5次超时就会断开连接


## 第二次握手丢包

第二次握手：服务端收到SYN后，将ACK发送给客户端。

第二次握手的目的：ACK确认收到第一次报文，SYN服务端发起连接请求。

如果第二次握手丢包，那么客户端收不到ACk会超时重传，同时服务器也会收不到ACk进行超时重传

默认为5次重传后还是没有ACK就断开连接，每次默认超时时间是上次的二倍

## 第三次握手丢包

第三次握手:客户端发送ACK给服务器,并进入ESTABLISHED。

因为是服务器收不到ACK，服务器会超时重传。

默认为5次重传后还是没有ACK就断开连接，每次默认超时时间是上次的二倍


## 什么是SYN攻击，如何避免

TCP是要三次握手建立连接的，假设攻击者短时间伪造不同IP发SYN报文，服务端每次收到SYN都进入SYN_RCD，但是服务端发出的ACK+SYN没有ACK，导致服务端半连接队列占满。

这就导致后续的TCP连接报文都会被丢弃，客户端无法连接服务器。

避免方式：

- 调大netdev_max_backlog

  - 网卡接收数据表的速度大于内核处理速度时，有个队列保存这些包，这个值是控制队列最大值的
- 增大TCP半连接队列
- 开启tcp_syncookies

  - syncookies 功能可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。
- 减少SYN+ACK重传次数

  - SYN 攻击时，会有大量处于 SYN\_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，会断开连接。
  - 可以减少 SYN-ACK 的重传次数，加快处于 SYN\_REVC 状态的 TCP 连接断开。
  - SYN-ACK 报文的最大重传次数由 `tcp_synack_retries`内核参数决定（默认值是 5 次），如将 tcp\_synack\_retries 减少到 2 次：
