HashMap:	用来存储和操作键值对（key-value pair）的数据。

	HashMap是用哈希表（hash table）来存储数据的，
	哈希表是一个数组，数组元素叫做桶（bucket），每个桶可以存储一个或多个键值对 。

	HashMap的长度指的是哈希表的长度，也就是桶的数量。

HashMap的长度为什么是2的n次，有以下几个原因：



方便计算哈希码值：
	哈希码值是根据key的内容计算得到的一个整数，决定了键值对在哈希表中的存储位置。
	如果HashMap的长度是2的n次，那么计算哈希码值时，只要对key进行一次异或运算和一次与运算，
		就可以得到一个介于0和长度-1之间的整数  。
	例如：
      
        	int hash = key.hashCode(); // 计算key的哈希码值
		hash ^= (hash >>> 16); // 对哈希码值进行异或运算，使高位和低位混合
		int index = hash & (length - 1); // 对哈希码值进行与运算，得到存储位置

      
      
方便扩容和缩容：
	扩容和缩容是指当HashMap中的数据量达到一定阈值时，动态地调整哈希表的长度，
		以保证数据的分布均匀和空间利用率高。
	
	加载因子是0.75,存储数据达到哈希表的75%时,触发扩容
	如果HashMap的长度是2的n次，那么扩容和缩容时，只要将长度乘以2或除以2，就可得到一个新长度

	例如：
      	  	int newLength = length * 2; // 扩容时，将长度乘以2
		int newLength = length / 2; // 缩容时，将长度除以2

      
      
方便避免哈希冲突：
	哈希冲突指当两个或多个key有相同的哈希码值时，会被存储在同一个桶中，导致性能下降。
	如果HashMap的长度是2的n次，可以利用一种叫做红黑树的数据结构来优化桶中数据的存储和查找 。
	红黑树:一种自平衡的二叉搜索树，可保证最坏情况下，查找、插入、删除操作的时间复杂度都是O(logn)
	
	若桶中数据超过8个，会将链表转换为红黑树；
	若桶中数据少于6个，就会将红黑树转换为链表 。



