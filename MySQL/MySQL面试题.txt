什么是MySQL?
	
	一个关系型数据库.采用表的形式存储数据.  有表结构,即行和列.并且有数据类型

数据库的三大范式?
	
	第一范式1NF:		确保数据库表字段的原子性			就是说一列的信息最细化,粒度降低
						如:   '广东110' 要分成两个字段 :'广东' '110'
	
	第二范式2NF:		确保第一范式的前提下,
					要求表必须有一个主键,并且非主键完全依赖于主键,而不是依赖主键的一部分
						如:	一个学生对于n个课程,一个课程也有m个人学.
							这种情况下,要拆分成三个表,学生表,课程表,选课关系表
					
					可以避免数据冗余和插入异常等问题

	第三范式3NF:		满足第二范式的前提下,
					非主键列		必须直接依赖于主键,不能存在依赖传递关系.
						如:	课程号->职工号->教师资料
							对于上述这种表,会出现问题.修改课程教师时,要修改大量字段.
							如果要删除课程,会导致教师资料也被删除.

事务的四大特性

	原子a	:	事务要么成功,要么失败			
		
	一致c	:	执行前后必须一致状态					如:	a给b转了1000块,无论成功后失败钱总和不变

	隔离i	:	分隔离级别,处理事务与事物之间的关系		
			事务隔离出现的问题
				脏读			:读了另一个事务没有提交的数据
				不可重复读	:一个事务的多次相同查询的结果不一致,在查询时另一个事务 修改 了数据
				幻读			:一个事务的多次相同查询的结果不一致,再查询时另一个事务 插入 了数据
					不可重复读	只是读的数据有差异
					幻读			会报错
			事务隔离级别解决对应问题
				读未提交:		可以读到其他事务没有提交的数据			
				读已提交:		不能读取其他事务没有提交的数据		解决脏读
				可重复读:		在一个事务中的多次读取数据一致		解决不可重复读		
				串行化:		强制不同事务的执行先后有序,互斥		解决幻读

	持久d	:	事务一旦提交,对数据库的改变是永久的


生产环境数据库一般用的什么隔离级别呢？

	一般使用RC(读已提交), 
			RR下有间隙锁,死锁概率大.
			RR下,条件列未命中索引会锁表	RC下只锁行
		也就是说 RC的并发大于RR
		并且多数情况下,不可重复读可以被接受.毕竟数据已经提交,读取本身问题不大



编码和字符集的关系
	编码:		按照一定规则把符号和二进制码对应起来
	
	字符集:		已经编码的字符聚集在一起就是字符集

	中文	:	GB2312		俄语:	cp866		希腊语:	greek

	统一万国码:	Unicode		对于字母数字,Unicode用2字节表示
	
	UTF-8:		Unicode表示字符时,有大量数字0可以缩略	

	
UTF8 和 UTF8mb4 的区别
	
	mysql支持的字符集中有utf8和utf8mb4。

	utf8mb4编码，mb4就是most bytes 4，最大支持用4个字节表示字符，几乎可表示目前已知的字符。

	utf8,也叫utf8mb3，是数据库的默认字符集, 最多支持用3个字节去表示字符
		
		utf8 是阉割版的utf8mb4，只支持部分字符。比如emoji表情就不支持。


	UTF8mb4的劣势:	表示字符的时候多占用一个字节空间
		如:	char(2) 在两种编码下,一个表示6字节,一个为8字节

索引
	数据存在磁盘中,查询数据时没有索引会加载所有数据到内存依次检索,读取磁盘次数多,效率低
	有索引就不需要加载所有数据,因为B+树一般为2-4层,最多只用读取2-4次磁盘	

	优点:	加快数据查询,排序,分组效率
			加快表与表的连接
	
	缺点:	索引要占用空间
			降低表的增删改的效率,每次增删改要动态维护索引

什么情况下使用索引?
	
	经常用于查询的字段	经常用于连接的字段	经常需要排序的字段
	
什么情况下不使用索引?
	
	where条件中用不到的字段
	表记录少的时候
	需要经常增删改的字段
	参与列运算的字段
	区分度不高的字段
	
索引的数据结构
	
	主要有B+树和哈希表.对应的索引分别是B+树索引和哈希索引
	InnoDB引擎支持B+树和哈希索引.默认是B+树索引
	
	B树:		多路平衡查找树	每个节点可以存多个key-val		在插入元素时采用中间值向上分裂
	
	B+树:	在B树的基础上,
				让每个非叶子节点只存key,只有叶子节点存key-val	为了降低层级让一个节点存更多key
				
	mysql对B+树的优化
			在B+树上的叶子节点加了一个双向链表支持区间访问
			插入元素使叶子节点分裂时,不采用对半分,而是中间值向上提升
			删除时不采用合并节点,而是借父节点一个元素,并移动元素最多的兄弟节点的元素到父节点
				
	

哈希索引
	
	哈希索引基于哈希表实现,存储引擎会对索引列哈希计算哈希码,并尽量保证哈希码值不同.
	将哈希码值作为哈希表key值.将指向数据行的指针作为哈希表的val值
		
Hash索引和B+树索引的区别？
	
	哈希索引不支持排序,							因为哈希表无序
	哈希索引不支持范围查找
	哈希索引不支持模糊查询和多列索引的最左前缀
	哈希索引会哈希冲突,性能不稳定.B+树性能稳定,每次查询都是从根节点到叶子节点

为什么B+树比B树更适合数据库
	
	B+树数据存在叶子节点中,方便区间访问.而B树只能通过中序遍历
	B+树非叶子节点只存索引key,让以页为单位的索引可以存更多节点,减少IO
	B+树查询效率更稳定,关键字查询路径长度相同

索引有什么分类
	
	主键索引:		非空索引,不许有空值

	唯一索引:		索引列的值必须唯一,允许设置空值.
			唯一索引和主键索引区别:	
				唯一索引字段可以为null并且可以有多个空值
				主键索引字段不能为null

	组合索引:		表中多个字段组合创建的索引,只有在查询条件中使用了这些字段左边字段时,索引才被使用
				遵循最左前缀法则
	
	全文索引:		只能在char,varchar,text类型字段上使用全文索引
	
	普通索引:		最基本的索引,没有任何限制,值可以为空
	

什么是最左前缀法则
	
	如果用到了组合索引最左边的索引,那就可以利用该索引查询,当遇到范围查询会停止查询
	例:	对a,b,c建立组合索引,那只有查询条件a/ab/abc才能生效
	例:	对a,b,c建立组合索引,那查询条件ac中,只有a生效

						

什么是聚集索引?
	
	InnoDb使用表的主键构造主键索引树,同时叶子节点中存放的即为整张表的记录数据
	聚集索引叶子节点的储存是逻辑上连续的,使用双向链表连接,所以主键的排序查询和范围查询速度快
	聚集索引的叶子节点就是整张表的行记录,InnoDB主键使用的是聚集索引.
	聚集索引比非聚集索引查询效率高很多
	
什么是覆盖索引?
		
	查询的数据列可以再索引中找到,不需要回表查询,即查询列被使用的索引覆盖
	
	不是所有类型的索引都可以成为覆盖索引.覆盖索引要储存索引列的值,而哈希索引,全文索引不储存索引列的值
		索引MySQL使用B+树索引做覆盖索引


索引的设计原则
	
	经常查询的字段建立索引
	经常排序,分组,联合操作的字段建立索引
	索引列的区分度越高,效果越好.				如性别这种效果只有两种可能得字段效果就不好
	尽量使用短索引,长字符串要给出较短前缀索引	
	避免给大字段建立索引						占用空间和耗费排序时间
	索引不是越多越好
	频繁修改的字段不用建立索引
	利用最左前缀法则

索引什么时候失效?

	组合索引的最左前缀法则
	%开头的模糊匹配不能使用索引						如 '%aa'不能使用,但是'aa%'可以使用	
	查询条件中列类型是字符串没加引号可能导致索引失效		可能因为类型不同发生隐式转换
	'!=','>','<'索引失效
	对索引列进行计算,索引失效	
	查询条件使用 or 连接,索引失效

什么是前缀索引
	
	需要在很长的字符串字段建立索引时,索引会特别大还慢
	
	前缀索引就是对文本或字符串的前几个字符建立索引,这样索引短且快

	要注意:	要评估好索引的前几个字符的重复率,也叫索引选择性
	


常见的存储引擎
	
	MySQL4种,	MyISAM,InnoDB,MEMORY,ARCHIVE,		MySQL5.5版本后,默认引擎为InnoDB
	
	InnoDB:		默认的事务型存储引擎, 使用最广泛基于聚集索引建立.
				内部有很多优化,如可以在内存中创建自适应hash索引,加速读操作
		优点:	支持事务和崩溃修复能力.	引入行锁和外键
		缺点:	占用数据空间大
		场景:	需要事务支持,有较高并发读写频率
		
	MyISAM:		数据按照紧密格式存储.对只读数据或表比较小,可以容忍修复操作. 那可以使用MyISAM引擎
				将表存在两个文件中,数据文件 .MYD和索引文件 .MYI
		优点:	访问快
		缺点:	不支持事务,行锁. 	不支持崩溃安全恢复,不支持外键
		场景:	对事务没要求,数据都只读

	MEMORY:	将数据放内存中,访问速度快.但系统崩溃时数据丢失
				默认使用哈希索引,将键的哈希值和执行数据行的指针保存在哈希索引中
		优点:	访问速度快
		缺点:	哈希索引不是按顺序储存,无法排序	
				不支持部分索引匹配,因为是按照索引列全部内容计算哈希
				只支持等值查询,不支持范围查询
				哈希冲突时,要遍历链表中所有行指针,逐行比较
	
	ARCHIVE:	适合储存大量独立的,作为历史记录的数据
				提供了压缩功能,高效插入速度.
				但是不支持索引,查询速度慢

MyISAM和InnoDB区别
	
	储存结构	:	MyISAM在磁盘中分为三个文件,.frm表定义文件,.MYD数据文件,.MYI索引文件
				InnoDB所有表存在一个数据文件中(也可能多个),大小只受限于操作系统大小

	存储空间区别:	MyISAM支持三种格式:	静态表,动态表,压缩表. 
				InnoDB需要更多内存和储存,在主内存中建立专门的缓冲池高索缓冲数据和索引

	可移植,备份和恢复:	
				MyISAM数据按文件形式储存,跨平台很方便.备份和恢复可单独针对表操作
				InnoDB,要拷贝数据文件,或备份binlog,或用mysqldump.数据量很大时很麻烦
	
	是否支持行锁
				MyISAM只支持表锁,执行SQL语句时加表锁
				InnoDB支持行锁和表锁,大幅度提高并发操作性能
	
	是否支持事务和崩溃后安全恢复
				MyISAM不支持事务
				InnoDB支持事务,有事务回滚和崩溃修复能力

	是否支持外键
				MyISAM不支持，而InnoDB支持。

	是否支持MVCC
				MyISAM不支持
				InnoDB支持MVCC。应对高并发事务，MVCC比单纯的加锁更高效。

	是否支持聚集索引
				MyISAM不支持聚集索引，InnoDB支持聚集索引。

	全文索引
				MyISAM支持 FULLTEXT类型全文索引
				InnoDB不支持FULLTEXT类型全文索引，但innodb使用sphinx插件支持全文索引，效果更好

	表主键
				MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址
				InnoDB如果没有设定主键或者非空唯一索引，会自动生成一个6字节的主键(用户不可见)。

	表的行数		
				MyISAM保存有表的总行数，select count(*) from table;会直接取出该值。
				InnoDB没有保存表的总行数，select count(*) from table；会遍历整个表，消耗大，
					但加了where条件后，MyISAM和InnoDB处理的方式一样。

				
MySQL有哪些锁
	
	按锁的粒度:	行锁,表锁,页锁
		行锁:	mysql最小的锁,值针对当前操作的行加锁,减少了数据库操作并发冲突,粒度小,开锁开销小
			分三类:	RecordLock:		记录锁,锁住一条记录
					GapLock:		间隙锁,锁定一个范围,但不包含记录本身
					Next-KeyLock	上两种的结合,锁定一个范围,并锁定记录本身
		表锁:	mysql粒度最大的锁,对当前操作的表加锁. 实现简单,消耗少.
				大部分引擎支持
		
		页锁:	介于表锁和行锁之间的锁, 表锁速度快但冲突多.行锁冲突少速度慢.
				页锁折中,一次锁定相邻的一组记录

	按锁的级别分类:	共享锁,排他锁,意向锁
			
		共享锁:	也叫读锁:		读取操作创建的锁,并发读取,但是与修改操作排斥
		排他锁:	也叫独占锁:	只有施加该锁的事务才能操作(读和写)该数据
		意向锁:	意向锁是表级锁,设计目的是: 在一个事务中揭示将要被请求的数据的锁的类型
			InnoDB的两种表锁:
				意向共享锁:	表示事务准备给数据加共享锁		此时需要获取数据当前锁状况
				意向排他锁:	表示事务准备给数据加排他锁		此时需要获取数据当前锁状况
					
				意向锁是InnoDB自动施加,不需要用户操作
					修改操作加排他锁,查询操作不加锁

MVCC实现原理:	
		
	MVCC:		就是同一份数据保留多版本的方式,并实现并发控制
				查询时已通过readview和版本链找对应版本的数据
		作用:	提升并发性能.高并发下,MVCC比行锁开销小
	
	实现原理:		依赖版本链,版本链通过表的三个隐藏字段实现
		DB_TRX_ID:		当前事务ID		
		DB_ROLL_PTR:	回滚指针,指向当前行的上一个版本,形成链表,叫做undolog版本链
		DB_ROW_ID:		主键(或者隐藏主键)
	
	使用事务更新行记录时,会形成版本链.	
		执行过程:		该行加排他锁
					将原本的值拷贝到undolog作为旧版本,
					修改当前行的值形成新版本
					更新事务id,回滚指针
		
		readview:		可理解成将数据每个时刻的状态拍快照记录。
						获取时刻t数据时，到t时间点的快照取数据。
				在read view内部维护活跃事务链表，表示生成read view时还在活跃的事务。
				链表只包含创建read view前还未提交的事务
		
			不同隔离级别创建read view时机

				RC：每次执行select创建新的read_view，保证读到其他事务已经提交的修改。

				RR：一个事务第一次select时更新read_view，后续select复用之前的read_view
					保证事务范围内每次读取的内容一样，即可重复读。
			
			read view判断版本可见方式
				DATA_TRX_ID :	每个数据行的最新的事务ID；
				up_limit_id:		当前快照中的第一个事务；
				low_limit_id:		最后一个事务。

			DATA_TRX_ID < up_limit_id：	当前事务已提交，该版本可被读取
			DATA_TRX_ID >= low_limit_id：当前事务是创建read view后创建，该版本不可见。
					此时要通过版本链找上一个版本，重新判断该版本的记录对当前事务的可见性。
			up_limit_id <= DATA_TRX_ID < low_limit_i：
					要在活跃事务链表中查找是否存在ID为DATA_TRX_ID的事务。
						如果存在，由活跃事务链表中的事务是未提交的，该版本不可见。
							要通过版本链找到上一个版本，重新判断该版本的可见性。
						如果不存在，说明事务trx_id 已经提交，该版本可见。

	总结:	InnoDB 的MVCC是通过 read view 和版本链实现，版本链保存历史版本记录，
			通过read view 判断当前版本的数据是否可见，如果不可见，再从版本链中找到上一个版本，
			继续进行判断，直到找到一个可见的版本。


快照读和当前读
	
	表记录由两种读取方式:
		快照读:	读取快照版本,普通select是快照读,通过MVCC进行并发控制,不加锁
		当前读:	读取最新版本. 	update,delete,insert,select ..for update,select..lock in share mode

	快照读下,InnoDB通过MVCC避免幻读.但是mvcc无法避免当前读情况下出现的幻读,
			因为当前读读取的是最新数据

	如何避免幻读?
		快照读下,通过MVCC避免
		当前读下,通过next-key避免幻读(通过行锁和间隙锁实现)
			next-key分两部分: 行锁和间隙锁.行锁是加索引上,间隙锁加在索引之间
			
		串行化也避免幻读,但是效率低
	
共享锁和排他锁
	select读取锁定有两种方式:	共享锁和排他锁
		select ...in share mode;--共享锁			select ...for update;--排他锁

		两种方式的区别是	第二种在多个事务同时更新同一表时容易造成死锁

		排他锁
			前提:		没有线程对该结果的行数据使用排他锁或共享锁,否则阻塞
			结果:		事务操作时,MySQL对查询结果集的行数据添加排他锁,阻塞其他线程的修改操作
	
		select ...for update注意事项:
			for update 只适用于InnoDB,并且要在事务范围内才能生效
			按照主键查询,查询条件时'like'或'!='的时候,主键字段产生表锁
			按照非索引字段查询时,产生表锁
		
bin log/redo log/undo log

	MySQL日志主要包括 查询日志,慢查询日志,事务日志,错误日志,二进制日志等
		其中 binlog(二进制日志)   redolog(重做日志)  undolog(回滚日志)比较重要

	binlog:		mySQL的数据库级文件,记录对MySQL的所有修改操作.用于恢复数据库和同步数据库
	redolog:		InnoDB的引擎级文件,记录InnoDB的事务日志,不论是否提交都记录,用于数据恢复
				当数据库故障时,InnoDB会使用redolog恢复到故障前的时刻来保证数据的完整性
	undolog:	记录数据修改前的内容,通过undolog实现事务回滚,并可以根据undolog回溯版本
				还可以实现MVCC
	
binlog和redolog区别
	
	binlog记录所有日志记录,包括存储引擎的日志		redolog只记录InnoDB本身的记录
	binlog只在事务提交前写入磁盘,一个事务写一次		redolog在事务过程中不断写入磁盘
	binlog是逻辑日志,记录SQL的原始逻辑				redolog是物理日志,记录某个数据页上的修改


MySQL架构
	主要分为 服务层 和 引擎层		
		服务层:	包括连接,缓存查询,分析,优化,执行等.所有跨存储引擎功能的实现
				如: 存储过程,触发器,视图,函数,binlog等
		引擎层:	负责数据的存储和读取.服务层通过api和引擎通信

	服务层基本组件:
		连接器:		进行身份认证和权限校验
		缓存查询:		查询语句先校验SQL是否查询过,查询缓存.如果没有缓冲在执行查询
		分析器:		没有命中缓存,SQL就要经过分析器.进行词法分析和语法分析
					再坚持SQL语句语法正确性
		优化器:		对查询优化,包括重写查询,决定表的读写顺序以及选择合适索引,并生成执行计划
		执行器:		执行前校验用户有没有权限,
						没有权限会返回错误信息
						有就根据执行计划调用引擎接口并返回结果


分库分表
		当单表数据量达到1000W或100G后,优化索引,添加从库的效果就不明显了.此时需要考虑对其切分.
		切分目的是减少数据库负担,缩短查询时间

	数据切分分为两种:	垂直划分和水平划分
	
	垂直划分:		根据业务划分，如购物场景，可以将库中涉及商品、订单、用户的表分别划分出成一个库，
				降低单库大小提高性能。同样，分表的情况就是将大表根据业务功能拆成多个子表，
				如商品基本信息和商品描述，商品基本信息一般展示在商品列表，商品描述在商品详情页，
				可以将商品基本信息和商品描述拆分成两张表。

		优点:	行记录变小,数据页可以存更多记录,减少IO
		缺点:	主键出现冗余,需要管理冗余列
				会引起表连接JOIN操作.可以通过业务服务器上进行join减少数据库压力
				依然存在单表数据量大的问题
		
	水平划分:		根据一定规则，如时间或id序列值等进行数据拆分。如根据年份来拆分不同的数据库。
				每个数据库结构一致，但数据得以拆分，从而提升性能。

		优点：	单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动少。

		缺点：	分片事务一致性难以解决	
				跨节点join性能差，逻辑复杂
				数据分片在扩容时要迁移


什么是分区表
	
	分区是把一张表的数据分为n个区块. 分区表是一个独立的逻辑表.由多个物理子表组成

	当查询条件的数据分别在某一分区时,查询引擎只会在某个分区查询,而不是遍历整个表
	
	分区一般是放在单机中,一般是时间范围分区,方便归档.只不过分库分表需要代码实现,分区是mysql内部实现
		分库分表和分区不冲突,可以结合使用

分区表类型
	
	range分区,
		按照范围分区,如:按照时间范围分区
		分区表创建:	
			CREATE TABLE test_range_partition(
       				id INT auto_increment,
       				createdate DATETIME,
       				primary key (id,createdate)
   			) 
   				PARTITION BY RANGE (TO_DAYS(createdate) ) (
   					PARTITION p201801 VALUES LESS THAN ( TO_DAYS('20180201') ),
     					PARTITION p201802 VALUES LESS THAN ( TO_DAYS('20180301') ),
      					PARTITION p201803 VALUES LESS THAN ( TO_DAYS('20180401') ),
      					PARTITION p201804 VALUES LESS THAN ( TO_DAYS('20180501') )
			   );

		在/var/lib/mysql/data/可以找到对应的数据文件，每个分区表都有一个使用#分隔命名的表文件


	list分区
		list分区和range分区相似,区别在于list是枚举值列表的集合,range是连续的区间值的集合
		list分区,分区字段必须已知.如果插入的字段不在分区时的枚举值中,将无法插入
		分区表创建
			create table test_list_partiotion
			   (
			       id int auto_increment,
			       data_type tinyint,
			       primary key(id,data_type)
			   )partition by list(data_type)
			   (
			       partition p0 values in (0,1,2,3,4,5,6),
			       partition p1 values in (7,8,9,10,11,12),
			       partition p2 values in (13,14,15,16,17)
			   );

	hash分区
		可以将数据均匀分布到预先定义的分区中
		分区表创建:
			create table test_hash_partiotion
			   (
			       id int auto_increment,
			       create_date datetime,
			       primary key(id,create_date)
			   )partition by hash(year(create_date)) partitions 10;

分区的问题:
		打开和锁住所有底层表的成本高.查询访问分区表时,MySQL要打开并锁住所有底层表
			这个操作在分区过滤前发生,导致无法通过分区过滤来降低次开销,影响查询速度

		维护分区成本高,如重组分区,会先创建一个临时分区,再将数据复制到其中,最后删除原分区

		所有分区必须用相同的存储引擎

查询语句执行流程
	
		权限校验	查询缓存	分析器	优化器	权限校验	执行器	引擎

更新语句执行流程
		
		分析器	权限校验	执行器	引擎	redolog(prepare状态)	binlog	redolog(commit状态)

		binlog要在redolog的prepare状态下进行,
			因为在redolog后的话,如果写入redolog后机器挂了,binlog就没有被记录.
			但机器重启后通过redolog成功恢复数据,binlog就少了数据

exist和in的区别
		exist用于对外表记录筛选
			exists会遍历外表，将外查询表的每一行代入内查询判断。
			当exist里的条件语句能返回记录行时，条件就为真，返回外表当前记录。
			反之不能返回记录行，条件为假，则外表当前记录被丢弃。
	
		in是先把后边的语句查出来放到临时表中，然后遍历临时表，将临时表的每一行，代入外查询去查找。

		也就是说exist会遍历外表,in会遍历内表

		所以子查询的表比较大时，用exists可以有效减少总循环次数提升速度；
		当外查询的表比较大的时候，用in可以有效减少对外查询表循环遍历来提升速度。

MySQL中int(10)和char(10)的区别？
		
		int(10)中的10表示的是显示数据的长度，而char(10)表示的是存储数据的长度。

truncate、delete与drop区别？
	相同：	truncate和不带where子句的delete、以及drop都会删除表内的数据。
			drop、truncate都是DDL语句（数据定义语言），执行后会自动提交。
	不同：	truncate 和 delete 只删除数据不删除表的结构；
			drop 语句将删除表的结构被依赖的约束、触发器、索引；
			一般来说，执行速度: drop > truncate > delete。

having和where区别？
	二者作用对象不同，where子句作用于表和视图，having作用于组。
	where在数据分组前进行过滤，having在数据分组后进行过滤。

为什么要做主从同步？
	读写分离，使数据库能支撑更大并发
	在主服务器上生成实时数据，在从服务器上分析这些数据，提高主服务器的性能。
	数据备份，保证数据的安全。

什么是MySQL主从同步？
	主从同步使数据从一个数据库服务器复制到其他服务器，复制数据时，一个服务器充当主服务器（master），	其余的服务器充当从服务器（slave）

	复制是异步进行，从服务器不需要一直连接主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器	通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。


乐观锁和悲观锁是什么？
	并发控制是确保多个事务同时存取数据库中同一数据时不破坏事务的隔离性和一致性以及数据库的一致性。
	乐观锁和悲观锁是并发安全主要采用的技术手段。

	悲观锁：
		假定会发生并发冲突，对操作的数据加锁，直到提交事务才释放锁，其他事务才能修改。
		实现方式：使用数据库中的锁机制。

	乐观锁：
		假设不会发生并发冲突，只在提交操作时检查数据是否被修改过。
		实现方式：给表增加version字段，修改提交前检查version与原来取到的version值是否相等，
			若相等，表示数据没有被修改，可以更新，
			否则，数据为脏数据，不能更新。
		一般使用版本号机制或CAS算法实现。

用过processlist吗？
	show processlist 或 show full processlist 查看当前 MySQL 是否有压力，有没有慢SQL在执行。

	返回参数如下：
		id：线程ID，可以用kill id杀死某个线程
		db：数据库名称
		user：数据库用户
		host：数据库实例的IP
		command：当前执行的命令，比如Sleep，Query，Connect 等
		time：消耗时间，单位秒
		state：执行状态，主要有以下状态：
			Sleep，线程正在等待客户端发送新的请求
			Locked，线程正在等待锁
			Sending data，正在处理SELECT查询的记录，同时把结果发送给客户端
			Kill，正在执行kill语句，杀死指定线程
			Connect，一个从节点连上了主节点
			Quit，线程正在退出
			Sorting for group，正在为GROUP BY做排序
			Sorting for order，正在为ORDER BY做排序
		info：正在执行的SQL语句


MySQL查询 limit 1000,10 和limit 10 速度一样快吗？
	
	两种方式:		limit offset, size	和 limit size		其中limit size 其实就是 limit 0,size

	limit sql的内部执行逻辑:
		执行器可通过调用存储引擎的接口，将数据取出，当这些数据符合要求会放到结果集中，返回给客户端
		当执行select * from xxx order by id limit offset size时,会从第offset行开始后的size行
			也就是说,会将0~offset+size条数据全部遍历一遍
		所以limit 10速度快


高度为3的B+树，可以存放多少数据？
	
	InnoDB存储引擎有自己的最小储存单元——页（Page）
		innodb 默认一页大小为 16384B = 16384/1024 = 16kb。
		MySQL中，B+树一个节点的大小设为一页或页的倍数最合适。
			因为如果一个节点的大小<1页，那读取节点的时候读取的还是一页，会造成资源的浪费。
	
		B+树中非叶子节点存的是key + 指针,叶子节点存数据行。
			对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据。
			对于非叶子节点，如果key使用的是bigint，则为8字节，指针在MySQL中为6字节，一共是14字节，
			则16k能存放 16 * 1024 / 14 = 1170 个索引指针。
		可以算出，一颗高度为2的B+树，每个叶子节点可以存储16条数据，一共 1170 x 16 = 18720 条数据。
		对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（两千多万条数据）


深分页怎么优化？

	深分页:	例:	select * from xxx order by id limit 500000, 10;
			一方面是页数太大影响性能,另一方面是如果该页为空浪费性能
	
	方法1:	
			可将sql语句修改成：
		select * from xxx where id >=(select id from xxx order by id limit 500000, 1) order by id limit 10;

			先执行子查询,在主键索引中获取500000+1条数据,再在server层抛弃前500000条,只留最后一条id
			不过这种方案在数据量大的时候依然比较耗时

	方法2:	
		将所有数据据id排序，再分批次取，将当前批最大id作为下次筛选的条件查询。
			select * from xxx where id > start_id order by id limit 10;
	
		就是先通过主键索引定位到起始数据的id,再往后遍历10个即可.这样查询性能比较稳定


大表查询慢怎么优化？

	当单表记录数过大时，数据库的性能会明显下降，常见的优化措施如下：

	合理建立索引。在合适的字段上建立索引，如在WHERE和ORDER BY涉及的列建索引，
				可根据EXPLAIN来查看是否用了索引还是全表扫描

	索引优化，SQL优化。最左匹配原则等

	建立分区。对关键字段建水平分区，如时间字段，若查询条件往往通过时间范围查询，提升性能

	利用缓存。用Redis等缓存热点数据，提高查询效率

	限定数据的范围。如：用户在查询历史信息的时候，可以控制在一个月的时间范围内

	读写分离。经典的数据库拆分方案，主库负责写，从库负责读

	通过分库分表的方式进行优化，主要有垂直拆分和水平拆分
	
	数据异构到es

	冷热数据分离。不常用的数据放到冷库中，比较新的数据放到热库中

	升级数据库类型，换一种能兼容MySQL的数据库（OceanBase、tidb）


MySQL单表多大进行分库分表？
	主流两种说法：
		MySQL 单表数据量大于 2000 万行，性能会明显下降，考虑进行分库分表。
		阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。

	这个数值其实和实际数据记录条数无关，与 MySQL 的配置以及机器的硬件有关。
		因为MySQL为提高性能，会将表索引装载到内存。如果InnoDB_BufferSize足够，索引能完全加载进内		存，查询不会有问题。但单表数据库到达某量级上限时，内存无法存储其索引，之后的SQL查询会产生
		磁盘 IO，导致性能下降。这还与具体的表结构的设计有关，最终导致的问题都是内存限制。

	因此，对于分库分表，要结合实际需求，不宜过度设计，项目一开始不采用分库与分表设计，要随业务增长
		在无法优化情况下，再考虑分库分表提高性能。
		阿里巴巴《Java 开发手册》补充：若预计三年后数据量达不到这个级别，不要在创建表时就分库分表。


说说count(1)、count(*)和count(字段名)的区别
	
	count(1) and count(字段名)的区别
		count(1) 统计表中的所有的记录数，包含字段为null 的记录。
		count(字段名) 统计该字段在表中出现的次数，不统计字段为null 的记录。

	三者之间的区别。

		执行效果上：
			count(*)包括所有的列，相当于行数，统计结果时，不会忽略列值为NULL
			count(1)包括忽略所有列，用1代表代码行，统计结果时，不会忽略列值为NULL
			count(字段名)只包括列名那一列，统计结果时，某个字段值为NULL时，不统计。

		执行效率上：
			列名为主键，count(字段名)会比count(1)快
			列名不为主键，count(1)会比count(字段名)快
			如果表多个列且没主键，count(1) 的执行效率优于 count(*)
			如果有主键，则 select count(主键)效率最优
			如果只有一个字段，则 select count(*)最优。

MySQL中DATETIME 和 TIMESTAMP有什么区别？
		
	TIMESTAMP和DATETIME都可存储时间，主要区别：

	1.表示范围
		DATETIME：1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999
		TIMESTAMP：'1970-01-01 00:00:01.000000' UTC 到 '2038-01-09 03:14:07.999999' UTC
		TIMESTAMP支持的时间范围比DATATIME小，易出现超出情况。
	2.空间占用
		TIMESTAMP ：占 4 个字节
		DATETIME：在 MySQL 5.6.4 之前，占 8 个字节 ，之后版本，占 5 个字节
	3.存入时间是否会自动转换
		TIMESTAMP在默认情况下，insert、update 数据时，TIMESTAMP列会自动以当前时间填充/更新。
		DATETIME则不会做任何转换，也不会检测时区，给什么数据，存什么数据。
	4.TIMESTAMP受时区timezone和MYSQL版本和服务器的SQL MODE的影响。
		因为TIMESTAMP存的是时间戳，在不同的时区得出的时间不一致。
	5.如果存进NULL，两者实际存储的值不同。
		TIMESTAMP：会自动存储当前时间 now() 。
		DATETIME：不会自动存储当前时间，会直接存入 NULL 值。