在运行期间,jvm会对代码优化

	原因:	jvm将执行状态分为5层
		0层:	解释执行(Interpreter)
		1层:	C1即时编译器编译执行(不带profiling)
		2层:	C1即时编译器编译执行(带基本profiling)
		3层:	C1即时编译器编译执行(带完全profiling)
		4层:	C2即时编译器编译执行

		profiling:	运行过程中收集一些程序执行状态的数据


	即时编译器(JIT)与解释器区别:
		解释器是将字节码解释为机器码,下次即使遇到相同字节码,还会执行重复解释
		JIT是将一些字节码编译为字节码,存入CodeCache,下次遇到相同代码,直接执行无需编译

		解释权是将字节码解释为针对所有平台都通用的机器码
		JIT会根据平台类型,生成平台特点机器码

	大部分不常用的代码,无需将其编译为机器码,而是采取解释执行的方式运行
	一方面,对应占据小部分的热点代码,则可以将其编译成机器码,达到理想的运行速度
	
	比较:	interpreter解释器<C1<C2		
	目标:	发现热点代码并优化




逃逸分析:	分析对象的动态作用域，判断对象是否会逃逸出方法或线程的范围，并进行一些优化措施，
		例如栈上分配、标量替换和同步消除等 。

	原理:	当一个对象在方法中被定义后，可能被外部方法或线程所引用，这种情况称为对象的逃逸。
	
		如，
			class Test {
			    static Object obj2;
			    public void test() {
			        Object obj1 = new Object(); // obj1在方法内部创建
			        someMethod(obj1); // obj1作为参数传递给另一个方法，发生方法逃逸
        			obj2 = new Object(); // obj2在方法内部创建
        			// obj2赋值给类变量，可能被其他线程访问，发生线程逃逸
    				}
			}

		如果一个对象没有发生逃逸，那它只能在方法内部被访问，这样它就不必分配到堆上，
		而是分配到栈上或直接替换为它的成员变量。
		这样可以减少堆上的对象数量，降低垃圾回收的开销，并提高程序的性能。


	栈上分配	:	将不会逃逸出方法的对象分配在栈上，而不是在堆上。
			避免在堆上分配内存和回收内存的开销，提高程序的执行效率。
	
	标量替换	:	将那些不会被外部引用的对象拆解成若干个基本类型的字段，
			减少对象的创建和访问，提高程序的执行效率。
			

	同步消除	:	去掉那些不会逃逸出线程的对象的同步锁，
			减少同步字段创建开销,提供并发性。
			(即如果锁不会被多个线程同时访问,就直接擦除锁字段)

	逃逸分析需要收集和分析大量的数据，因此也会带来一定的性能开销。

	
方法内联:	将被频繁调用的简单方法的代码直接嵌入到调用者的代码中，
		减少方法调用的开销，提高程序的执行效率。

	原理:	每次调用一个方法，需要进行一系列操作，如创建栈帧、传递参数、保存返回值、恢复栈帧等。		这些操作会消耗一定的时间和空间，
		如果方法本身的代码很简短，那么这些开销就会占据较大的比例，影响程序的性能。
		
	因此，如将这些简短的方法的代码直接替换掉调用语句，可以避免这些开销，提高程序性能。

	它需要收集和分析大量的数据，因此也会带来一定的性能开销。

	因此，并不是所有的Java 程序都能从方法内联中获得显著的性能提升，有时甚至会有负面的影响。
	因此，我们需要根据具体的场景和需求来决定是否开启方法内联 。]


字段优化:	根据对象的实际使用情况，对对象的字段进行一些调整和优化，
		减少内存占用和访问开销，提高程序的执行效率。

	主要包括以下几种方式：

	字段重排：调整对象中字段的存储顺序，减少内存碎片和对齐填充，提高内存利用率和缓存命中率。
	
		如:	一个对象有三个字段，分别是 byte、int 和 boolean 类型，
			那按照声明顺序存储时，要占用 12 个字节空间，其中有 3 个字节是对齐填充。
			但如果将这三个字段的顺序调整为 int、byte 和 boolean，
			那只需要占用 8 个字节的空间，没有对齐填充。

	字段拆分：将对象中不常用的字段分离，放到另一个对象中，
		减少对象的大小，提高缓存命中率和垃圾回收效率。
	
		如:	一个对象有两个字段，分别是 int 和 String 类型，
			其中 int 类型的字段常被访问，String 类型的字段很少被访问，
			那可以将 String 类型的字段拆分，放到另一个对象中，并用一个引用指向它。
			这样可以减少原对象的大小，提高缓存命中率和垃圾回收效率。

	字段合并：将对象中多个相同类型或相似类型的字段合并成一个数组或位域，减少对象的大小和访问开销

		如:	一个对象有多个 boolean 类型的字段，
			那可以将它们合并成一个 int 类型位域，每个位表示一个 boolean 值。
			可以减少对象的大小和访问开销。


反射优化:	
	缓存：	将反射过程中获取到的类、对象、字段、方法等信息缓存，
		避免重复查找和创建，提高反射的速度的技术。
	
		如，需要多次调用同一个类的同一个方法，那我们可以将该类和该方法的对象缓存起来，
			下次调用时直接使用缓存中的对象，而不需要再次通过字符串查找和创建 。

	预编译：将反射过程中涉及到的字符串转换为字节码或本地代码，
		避免解释执行，提高反射的速度的技术。
	
		如，通过反射调用一个方法，那可以将该方法的字符串表示转换为字节码或本地代码，
		并保存在一个类或接口中，然后通过正常的方法调用来执行该代码 。

	逃逸分析：如上
		逃逸分析对于反射优化有一定的帮助，因为它可以避免在堆上创建一些不必要的对象。






