索引:		帮助mysql高效获取数据的数据结构.
		数据库用这种数据结构来指向数据,实现高级查找算法
	

	优势:	提高数据检索效率,降低数据库io成本
		通过索引列队数据进行排序,降低数据排序的成本,降低cpu消耗

	劣势:	索引列也占用空间
		索引提供了查询效率,但是降低了更新表的速度,若对表信息增删改,效率降低


索引结构:	索引是在引擎层实现的,不同引擎有不同结构,主要包含:
		
			B+树索引			:最常见的索引类型,大部分引擎支持B+树
			Hash索引			:底层是哈希表,只支持精确匹配,不支持范围查询
			R-树索引(空间索引)	:MyISAM的特殊索引结构,用于地理空间数据类型
			Full-text索引(全文索引)	:建立倒排索引,快速匹配文档方式,类似于ES,Solr

					Innodb		MyISAM		Memory
		B+树索引			支持		支持		支持
		Hash索引			不支持		不支持		支持
		R-树索引(空间索引)	不支持		支持		不支持
		Full-text索引(全文索引)	5.6版本后支持	支持		不支持


二叉树:		缺点:顺序插入会形成链表,查询效率下降,大数据情况下,速度慢
红黑树:		缺点:大数据下层级别较深,速度慢

B树(多路平衡查找树):		每个节点可以储存多个key-value
	5阶B树节点:
		指针1,key1-val,指针2,key2-val,指针3,key3-val,指针4,key4-val,指针5

	B树的阶是按照一个节点中有多少个指针来计算,这些指针执行当前节点的子节点
	并且按照从左到右升序排序

	在插入时,主要是通过中间元素向上分裂处理
	设一个5阶B树节点为  2 3 5 6,现在向其中添加元素4
		那么就得到  2 3 4 5 6 超过4个元素,此时触发向上分裂,
			节点4转移到它的父节点,23和56作为4的左右两个字节点
		

B+树:		在B树的基础上添加一个单向链表连接所有子节点,并以最小节点为头
		并且所有关键数据存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)

B+树相对于B树的优势:
	磁盘读写性能更好，因为树的高度更低，磁盘I/O次数更少。
	扫描和排序性能更好，因为叶子节点之间有序链接，可以直接遍历。
	查询性能更稳定，因为每次查询都要到叶子节点，I/O次数是固定的。
	数据分布更均匀，因为键值可以重复，可以避免数据倾斜。


MySQL索引数据结构:
	叶子节点:	多个key-value,两个链表指针
	非叶子节点:	多个key,多个树的指针,整体被叫做页或块 (每页有16k空间,一行是1k)


	mysql索引数据结构对经典B+树进行优化		
	查询优化
		在B树基础上,增加了指向相邻叶子节点的链表指针,形成双向链表并成环,提供了区间访问性能
	插入优化:
		使叶子节点分裂时，不对半分，而是保持原有的叶子节点不变，将超出节点插入新叶子节点
		并把这个节点值提升到父节点。减少磁盘空间的浪费，提高插入性能
	删除优化:
		删除节点后，如某节点中元素数目小于最小值，会看其某相邻兄弟节点是否丰满，
		如果丰满，就向父节点借一个元素，并将最丰满的相邻兄弟节点中的一个元素上移到父节点中
		减少节点的合并操作，提高删除性能。

Hash结构:	哈希索引采用hash算法,将键值换算成hash值,映射到对应槽位,存在hash表中
		如果两个key算出的hash值相同,映射到同一个位置,就用链表挂在其下(哈希冲突)
		
		特点:	只能用于对等比较,不支持范围查询
			无法用索引完成排序操作
			查询效率高,通常一次检索即可,效率高于B+树

		MySQL中,支持hash的是Memory引擎,但是innodb中有自动适用hash功能,
		hash索引是引擎根据B+树在指定条件下自动构建


为什么innodb用B+树,而不用其他?
	相比于二叉树,层级少,效率高(红黑树也是特殊二叉树)
	相比于B树,无论叶子节点还是非叶子节点,都会保存数据,	
		导致页中存储的键值减少,指针减少,并保存大量数据,只能增加高度,导致性能下降
	相比于hash索引,B+树支持范围匹配和排序



索引分类:
	主键索引:	针对表中主键创建的索引	默认自动创建,只能有一个	primary
	唯一索引:	避免同一表中字段数据重复	可以有多个		unique
	常规索引:	快速定位数据		可以有多个		
	全文索引:	查找文本中关键词		可以有多个		fulltext


	根据索引的储存形式:
	聚集索引:	将数据储存与索引放一起,索引结构的叶子节点保存了行数据		有且只有一个
	二级索引:	将数据与索引分开储存,索引结构的叶子节点关联的是主键		可以有多个

			也就是说,如果使用二级索引,那么返回中自然就会有主键存在

	
	选取规则:	如果有主键,那么主键索引就是聚集索引
			如果没有主键,使用第一个唯一索引作为聚集索引
			如果没有主键和唯一索引,innodb会生成一个rowid作为隐藏的聚集索引
	

	回表查询:	先通过二级索引获取主键值,再用主键值获取行数据
	

	
	一行是1k,一页是16k.innodb指针占用6个字节,即使主键用bigint8字节,
		高度为2:		n*8+(n+1)*6=16*1024===>n=1170
		高度为3:		n=1170*1170*16   大约是	两千两百万条数据

索引语法:

	创建索引:create [unique|fulltext] index index_name on table_name (index_colname,..);

	查看索引:show index from table_name;

	删除索引:drop index index_name on table_name;


SQL性能分析:	
	SQL执行频次:	mysql通过  show [session|global] status  命令提供服务器状态信息
			
		show [session|global] status
			
			这个命令还可以查看增删改查操作的执行频次

	慢日志查询:	如果查询操作占多数
			慢日志查询可以提供所有执行时间超过指定参数(秒)的SQL语句的日志

		mysql的慢查询日志默认没有开启,在配置文件中配置:
			slow_query_log=1	#开启慢查询日志开关
			long_query_time=2	#设置慢查询日志的时间为2秒,超过就视为慢查询
		
				
		配置完毕后,通过重启启动数据库  systemctl restart mysql
		
		 show variables like 'slow_query_log';	# mysql查看慢查询日志是否开启

		查看	/var/lib/mysql/localhost-slow.log	就是慢日志文件



	profile详情:	profile能在做sql优化的时候帮助了解时间消耗的详情

		select @@hava_profiling		#查看当前mysql是否支持profile	

		默认profiling是关闭的,通过set语句在session/global开启profiling:
				
		set profiling=1;	#开启profiling功能	

		
		操作:	show rofiles;	 	查看每一条sql的基本情况
			show profile for query query_id;
						查看指定query_id的sql语句各个阶段耗时情况
			show profile cpu for query query_id;
						查看指定query_id的sql语句的使用情况


***	explain执行计划:		explain或desc命令获取mysql如何执行sql的信息
				包括select语句中表如何连接和连接的顺序

		语法:	explain select 字段 from 表名 where 条件;  #在select前加explain或desc


	explain获取字段信息的意义:
		
		id:	select 查询的序列号,表示查询中执行的顺序,
			id相同执行从上往下,越大越优先	
	
		select_type:	表示查询的类型,常见的有 
			simple:		简单表,即不使用表连接或子查询
			primary:	主查询,外层的查询
			union:		union中的第二个或后面的查询语句
			subquery:	select或where之后包含了子查询
	
	***	type:	表示连接类型,性能由好到差的连接类型
			null  > system > const > eq_ref > ref > range > index > all 
			尽量将type往前优化,一般到const(主键索引等)就比较好了

	***	possible_key:	
			显示可以应用在表上的索引,一个或多个

	***	Key:	实际使用的索引,如果是null,则没有使用索引
		
		
	***	key_len:    
			表示索引使用的字节数,为索引字段最大可能长度,不是实际长度
				在不损失精准的前提下,越短越好
	
		rows:	mysql任务必须要执行查询的行数,在innodb引擎的表中,是一个估计值,不一定准确
		
		filtered:	
			表示返回结果的行数占需读取行数的百分比,filtered的值越大越好

	***	extra:	额外信息
		
			

索引使用原则:
	验证索引效率:	在建立索引前执行sql,查询看看耗时,比较建立索引后区别
			一般区别是在几百倍
		

	最左前缀法则:	联合索引中,如果索引了多列,要遵守最左前缀法则.
			最左前缀法则指的是查询从查询从索引的最左列开始,并且不跳过索引中的列
		
			如果跳过了某一列,索引会部分失效,被跳过列后面的字段会失效

			
	范围查询:	联合索引中,出现了范围查询'>'或'<',范围查询右侧的列索引失效
		
		例: select * from tb_name where age>30 and status='0';
			其中范围查询是age>30,这样就导致status的索引失效
			要想规避,就要尽量使用 >= 或 <= 来查询,这样不会失效
			
			
			
	索引列运算:	尽量不要在索引列上进行运算操作,索引会失效
	
		例: select * from tb_user where subString(phone,10,2)='1';
		
		
	字符串加引号:	字符串类型字段使用时,不加引号,索引会失效
		
		例: select * from tb_user where phone=13333333333;

	
	模糊查询:	如果只是尾部模糊匹配,索引不会失效,如果头部模糊匹配,索引失效;
	
		例: select * from tb_user where profession like '%hhh';#不走索引,看'%'的位置
	
	or连接的条件:	用or分割的条件,如果or前的条件中列有索引,,后面的列没有索引
			那么涉及的索引失效

	数据分步影响:	MySQL评估使用索引比全表查询慢,则不使用索引
		
		例:	select * from tb_user where id >= 0;
		
		
	SQl提示:		SQL提示是优化数据库的手段,就是在SQL中加入一些人为的提示
		
		use index:	使用某索引
			select * from 表名 use index(索引名) where ...;
		ignore index:	不使用某索引
			select * from 表名 ignore index(索引名) where ...;
		force index:	强制使用索引
			select * from 表名 force index(索引名) where ...;
	

		其中,use index只是提示,不强制.可能接受,也可能不接受.


	覆盖索引:	尽量使用覆盖索引(查询使用了索引,并需要返回的列在该索引中可以全部能找到)
			减少使用select *

		如果用了覆盖索引:	
			explain的extra属性会出现:		
			using index condition	:	查找使用了索引,但是要回表查询
			using where;using index	:	查找使用了索引,但是不需要回表查询
		
			
	前缀索引:	当字段类型为字符串时,有时候需要为很长的字符串建立索引,导致索引占用内存太多
			此时,可以只将字符串的一部分前缀,建立索引,将大大节约索引空间,提高索引效率

		create index 索引名 on 表名(字段名(n))   # n是前缀长度

		前缀长度:	可根据索引的选择性决定,选择性是不重复索引值和数据表记录总数的比值
				索引选择性越高则效率越高
				如果唯一索引选择性为1,那么性能最好
		
		计算选择性:	select count(distinct 字段名)/count(*) from 表名;
			
	     前缀索引查询流程:
		针对字段的前n个字符来建立前缀索引
		先获取输入数据的前缀,通过前缀匹配前缀索引获取对应主键,用主键用聚集索引查行数据
		再对比行数据和输入数据,如果一样才返回,不一样还会再从前缀索引中查找
	
	

	单列索引与联合索引:	
		单列索引:	一个索引只包含一列
		联合索引:	一个索引包含多列	
		
		联合索引在满足返回值的情况下,可以避免回表查询,成为覆盖索引
		单列索引往往需要回表查询

		在业务中,如果有多个查询条件,考虑针对与查询字段建立索引时,建议建立联合索引

		多条件联查的时候,mysql会评估哪个字段索引效率高,并选择该索引完成查询
	
		

索引设计原则:		
		对大数据表且查询多的表建立索引
		对经常用查询条件where,排序(order by),分组(group by)操作的字段建立索引
		对区分度高的段建立索引,尽量建立唯一索引
		对字符串类型字段,如果长度较长,可以使用前缀索引
		尽量用联合索引,联合索引往往可以覆盖索引并且减少单列索引,节约空间,避免回表
		控制索引数量,索引太多会降低增删改效率
		如果索引列不能存null值,要在建表时用not null约束,这样优化器能更好选择索引	


总结:
	索引是高效获取数据的数据结构
	结构:		Hash  B+树

	分类:		主键索引,唯一索引,常规索引,全文索引,聚集索引,二级索引

	语法:		create [unique] index 索引名 on 表名(字段名,...)
			show index from 表名;
			drop index 索引名 on 表名;

	SQL性能分析:	执行频次,慢查询日志,profile,explain

	索引使用:	联合索引,索引失效,SQL提示,覆盖索引,前缀索引,单列/联合索引

	索引设计原则:	....









				


