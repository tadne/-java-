排序
		ES支持对搜索结果排序,默认采用相关度算分(_score)排序,
		可以排序的字段类型有:	keyword类型,数值类型,地理坐标类型,日期类型等
		如果采用了自排序就不会算分了

		GET /hotel/_search
		{
			"query": {
				"match_all": {}
			},
			"sort": [{
				"FIELD1":  "desc",
				"FIELD2":  "desc",
      				"_geo_distance": {					//按照距离排序
      				  	"location": "121.61, 31.03",		//经度和纬度
    		 	 		"order": "asc",
    			    		"unit": "km"
    			  	}
    			}]	
		}




分页		ES默认返回前10条数据,如果要查询更多需要修改分页参数
		ES通过修改form,size参数来控制要返回的分页结果:
			
		GET /hotel/_search
		{
			"query": {"match_all": {}},
			"from": 100,					//分页开始位置,第100条数据
			"size": 20,					//每页数量
			"sort": [{
					"price": {"order": "desc"}
			}]
		}
		
		ES底层分页:
				基于倒排索引,这导致如果你要查第100~120条数据,那么ES只能查询前120条数据再返回
				
				这样导致一个问题,集群状况下,这样的查询会成倍上升,
					例:	查询价格降序的前100个商品,那么需要每个节点都查出前100个商品,再排序
						最终处理的数据就变成了100*节点数量

				所以:	如果搜索页数过深或者结果集越大,对内存和CPU的消耗越高.
						因此,ES设定了结果集查询的上限是10000

		ES提供了两种深度分页解决方案:
			search after:		分页时需要排序,原理是从上一次的排序值开始,查询下一页数据(推荐)
			scroll:			原理是将排序数据形成快照,保存在内存(不推荐)	
		


		from+size:		优点:	支持随机翻页
						缺点:	深度分页问题,默认上限是10000
						场景:	百度,京东...
		after search:		优点:	没有查询上限(单次查询的size不超过10000)
						缺点:	只能向后逐页查询,不支持随机翻页
						场景:	手机向下滚动翻页
		scroll:			优点:	没有查询上限
						缺点:	有额外内存消耗,并且查询结果不是实时的
						场景:	海量数据获取迁移.ES不推荐采用该方案



高亮:	就是对搜索结果中将的关键字突出显示
		原理:	将搜索结果中的关键字用标签标记
				在页面中给标签添加css样式
		
		GET /hotel/_search
		{
			"query": {"match": {
				"all": "如家"
			}},
			"highlight": {
				"fields": {
					"name": {"require_field_match": "false"}	
				}
			}
		}
		
		注意:	高亮显示要求搜索字段和高亮字段一致
				如果不一致,那么要配置"require_field_match": "false"








