在运行期间,jvm会对代码优化

	原因:	jvm将执行状态分为5层
		0层:	解释执行(Interpreter)
		1层:	C1即时编译器编译执行(不带profiling)
		2层:	C1即时编译器编译执行(带基本profiling)
		3层:	C1即时编译器编译执行(带完全profiling)
		4层:	C2即时编译器编译执行

		profiling:	运行过程中收集一些程序执行状态的数据


	即时编译器(JIT)与解释器区别:
		解释器是将字节码解释为机器码,下次即使遇到相同字节码,还会执行重复解释
		JIT是将一些字节码编译为字节码,存入CodeCache,下次遇到相同代码,直接执行无需编译

		解释器是将字节码解释为针对所有平台都通用的机器码
		JIT会根据平台类型,生成平台特点机器码

	大部分不常用的代码,无需用JIT将其编译为机器码,而是采取解释执行的方式运行
	而占据小部分的热点代码,则可以将其编译成机器码,达到理想的运行速度
	
	比较:	interpreter解释器<C1<C2		
	目标:	发现热点代码并优化




逃逸分析:	分析对象的动态作用域，判断对象是否会逃逸出方法或线程的范围，并进行一些优化措施，
		例如栈上分配、标量替换和同步消除等 。

	原理:	当一个对象在方法中被定义后，可能被外部方法或线程所引用，这种情况称为对象的逃逸。
	
		如，
			class Test {
			    static Object obj2;
			    public void test() {
			        Object obj1 = new Object();// obj1在方法内部创建
			        someMethod(obj1); 		// obj1作为参数传递给另一个方法，发生方法逃逸
        			obj2 = new Object();		// obj2在方法内部创建
        			// obj2赋值给类变量，可能被其他线程访问，发生线程逃逸
    				}
			}

		如果一个对象没有发生逃逸，那它只能在方法内部被访问，这样就不必分配到堆上，
				而是分配到栈上或直接替换为它的成员变量。
		这样可以减少堆上的对象数量，降低垃圾回收开销，并提高程序的性能。


	栈上分配	:	将不会逃逸出方法的对象分配在栈上，而不是在堆上。
				避免在堆上分配内存和回收内存的开销，提高程序的执行效率。
	
	标量替换	:	将那些不会被外部引用的对象拆解成若干个基本类型的字段，
				减少对象的创建和访问，提高程序的执行效率。
			

	同步消除	:	去掉那些不会逃逸出线程的对象的同步锁，减少同步字段创建开销,提供并发性。
				(即如果锁不会被多个线程同时访问,就直接擦除锁字段)

	逃逸分析需要收集和分析大量的数据，因此也会带来一定的性能开销。

	
方法内联:	将被频繁调用的简单方法的代码直接嵌入到调用者的代码中，
		减少方法调用的开销，提高程序的执行效率。

	原理:	
		每次调用方法，需要进行一系列操作，如创建栈帧、传递参数、保存返回值、恢复栈帧等。			会消耗一定的时间和空间，如果方法的代码简短，那这些开销会占据较大比例，影响程序性能
		
	因此，将这些简短的方法的代码直接替换掉调用语句，可以避免开销，提高程序性能。

	但是也需要收集和分析大量的数据，因此也会带来一定的性能开销。

	因此，并不是所有的Java 程序都能从方法内联中获得显著的性能提升，有时甚至会有负面影响。
		我们需要根据具体的场景和需求来决定是否开启方法内联 。


字段优化:		根据对象的实际使用情况，对对象的字段进行一些调整和优化，
			减少内存占用和访问开销，提高程序的执行效率。

	主要包括以下几种方式：

	字段重排：调整对象中字段的存储顺序，减少内存碎片和对齐填充，提高内存利用率和缓存命中率。
	
		如:	一个对象有三个字段，分别是 byte、int 和 boolean 类型，
			那按照声明顺序存储时，要占用 12 个字节空间，其中有 3 个字节是对齐填充。
			但如果将这三个字段的顺序调整为 int、byte 和 boolean，
			那只需要占用 8 个字节的空间，没有对齐填充。


		字节对齐概念:
			Java 中的字节对齐规则与 C 语言中的规则类似，但是 Java 中的字节对齐规则是固定的，

			规则:	字节偏移量 可以被该数据类型所占字节数整除，					
					char可以放在任意位置，int放在剩下字节数可以被4整除的位置。
					整个结构体的大小一定要为占用最大空间类型的的整数倍
				例:	char,int,char:
						char一个字节,此时偏移量为1
						int4个字节,偏移量不满足被4整除条件,要填充3个字节,让偏移量为4	
						cahr1个字节,偏移量为8,满足条件,此时偏移量为9
						整个结构体的大小是 	占用最大类型空间的整数倍,所以是int的3倍:12

					
			不同的数据类型有不同的对齐要求。
				如:byte、boolean、char 类型的对齐要求为 1 字节，
				short 类型的对齐要求为 2 字节，int、float 类型的对齐要求为 4 字节，
				long、double 类型的对齐要求为 8 字节 。

	字段拆分：	将对象中不常用的字段分离，放到另一个对象中，
				减少对象的大小，提高缓存命中率和垃圾回收效率。
	
		如:	一个对象有两个字段，分别是 int 和 String 类型，
			其中 int 类型的字段常被访问，String 类型的字段很少被访问，
			那可以将 String 类型的字段拆分，放到另一个对象中，并用一个引用指向它。
			这样可以减少原对象的大小，提高缓存命中率和垃圾回收效率。
	
		
	字段合并：将对象中多个相同类型或相似类型的字段合并成一个数组或位域(BitMap)，
			减少对象的大小和访问开销

		如:	一个对象有多个 boolean 类型的字段，
			那可以将它们合并成一个 int 类型位域，每个位表示一个 boolean 值。
			可以减少对象的大小和访问开销。


反射优化:	
	缓存：	将反射过程中获取到的类、对象、字段、方法等信息缓存，
			避免重复查找和创建，提高反射的速度的技术。
	
		如，需要多次调用同一个类的同一个方法，那我们可以将该类和该方法的对象缓存起来，
			下次调用时直接使用缓存中的对象，而不需要再次通过字符串查找和创建 。

	预编译：将反射过程中涉及到的字符串转换为字节码或本地代码，
		避免解释执行，提高反射的速度的技术。
	
		如，通过反射调用一个方法，可以将该方法的字符串表示转换为字节码或本地代码，
		并保存在一个类或接口中，然后通过正常的方法调用来执行该代码 。

	逃逸分析：如上
		逃逸分析对于反射优化有一定的帮助，因为它可以避免在堆上创建一些不必要的对象。






