缓存：	高效读写的数据缓存区

	作用：	降低后端负载，提高服务读写响应速度
	成本：	开发成本（代码复杂），运维成本（集群部署麻烦），一致性问题


添加缓存模型：	查数据时先查缓存，缓存没有再查数据库，写入缓存，返回数据


缓存更新：	解决添加缓存时的一致性问题
		
		三种策略：	内存淘汰：	redis自带的内存淘汰机制，内存过多就清除
					过期淘汰：	利用expire给数据设置过期时间
					主动更新：	主动完成数据库与缓存的同时更新（常用）

		策略选择：	低一致性需求：	内存淘汰
					高一致性需求：	过期淘汰兜底，主动更新为主

		主动更新的方案：
					CacheAside：			缓存调用者更新数据库的同时完成对缓存的更新
										一致性好难度小
					Read/WriteThrough:	缓存和数据库集成为一个服务，保证一致性，暴露接口
										调用者调用api，不关心一致性。
										一致性好难度大性能一般
					WriteBack：			缓存调用者crud针对缓存完成，独立线程将数据写入数据库
										一致性差，性能好，实现复杂

			CacheAside模式的选择：	
					更新缓存和删除缓存中要选择删除缓存，
							因为更新缓存可能出现无效更新
					先操作数据库还是缓存要选择先更新数据库，
							因为操作数据库时间长，容易出现缓存击穿,(即缓存失效，大量请求到数据库)
					如何确保数据库和缓存操作原子性
							单体项目：	事务机制
							分布式项目:	分布式事务机制

			最佳实践:	
				查询数据时
						先查询缓存,缓存命中就返回,没有命中就查询数据库,再将数据库数据写入缓存
				修改数据时
						先修改缓存,然后删除缓存,确保两者的原子性




	缓存穿透:			缓存和数据库中都没有对应数据,导致请求一直打到数据库中
				
			解决:	缓存空对象:		对不存在的数据也建立缓存,并设置ttl
									实现简单,维护方便
									但有额外的内存消耗,短期数据不一致问题
					布隆过滤:			用布隆过滤算法,再请求进入redis之前判断是否存在,不存在直接拒绝									内存占用少
									实现复杂,存在误判的可能性

					其他:	做好数据的基础格式校验
							加强用户权限校验
							做好热点册数的限流

	缓存雪崩:			大量缓存key同时过期,导致大量请求到达数据库或redis服务宕机

			解决:	给不同key的ttl添加随机值
					利用redis集群提高服务的可用性
					给缓冲业务添加降级限流策略
					给业务添加多级缓存

	缓存击穿:			热点key在某一时间段被高并发访问,而且缓存重建的时间较长
					这种key突然过期,会导致缓存重建时,大量请求到达数据库

			解决:	互斥锁:	思路:	给重建过程加锁,确保重建过程只有一个线程执行,其他线程等待
							优点:	实现简单,没有额外内存消耗,一致性好
							缺点:	等待导致性能下降,有死锁风险
		
					逻辑过期:	思路:	热点key缓存永不过期,而是设置一个逻辑过期时间,查询时判断过期,
									如果过期才重建缓存
									重建缓存通过互斥锁保证单线程执行,用独立线程异步执行
							优点:	线程无需等待,性能好
							缺点:	不保证一致性,有额外内存消耗,实现复杂

			当然这些逻辑其实都可以直接封装到工具类中,直接调用
















			