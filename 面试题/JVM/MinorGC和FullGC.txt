Minor GC 和 Full GC 是两种不同的垃圾回收行为，分别针对堆内存中的新生代和老年代进行回收，释放无用的对象占用的空间。

Minor GC 和 Full GC 的触发机制主要有以下几种：
	Minor GC 的触发机制：
		当新生代的 Eden 区域被分配满时，会触发一次 Minor GC，
		把 Eden 区域中仍然存活的对象复制到 Survivor 区域或者老年代，然后清空 Eden 区域。
		Minor GC 通常会频繁地发生，但是耗时较短，一般不会对程序的执行造成太大的影响。

	Full GC 的触发机制：
		有以下几种情况会触发 Full GC：
		
		老年代空间不足，无法为新生代晋升的对象分配足够的空间。
			可能是由于创建了过大的对象或数组，或者新生代对象存活时间过长而进入老年代。
			
			可以调大老年代的大小，或者调整新生代的大小和对象晋升的年龄阈值。

		元空间（或永久代）空间不足，无法为加载的类、常量、静态变量等数据分配足够的空间。
			可能是由于系统中要加载的类、反射的类和调用的方法较多。
			
			可以调大元空间（或永久代）的大小，或者使用 CMS GC。

		空间分配担保失败，
			即在发生 Minor GC 之前，虚拟机检查老年代最大可用的连续空间是否
			大于新生代所有对象总空间，如果不成立，则可能会触发 Full GC。
			
			可以调整堆内存的初始大小和最大大小，或者关闭空间分配担保机制。

		CMS GC 时出现 promotion failed 或 concurrent mode failure，
			即在进行 CMS GC 过程中，有对象要放入老年代而空间不足造成的。
			这种情况下会退化使用 Serial Old 收集器变成单线程的。
			
			可以增加老年代的预留空间，或者降低触发 CMS GC 的阈值。

		调用 System.gc() 方法，建议虚拟机执行 Full GC，但不一定会真正执行。
			这种方式不推荐使用，应该让虚拟机自己管理内存。