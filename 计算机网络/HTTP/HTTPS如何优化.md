## HTTPS如何优化

HTTPS通过加密协议确实提高了安全性，但是安全的同时又性能问题

HTTPS相比HTTP多了TLS握手过程，**为了通过非对称加密协议交换出非对称加密密钥**，这个过程最多花2RTT，之后都得使用对称加密密钥进行加密\解密传输

- 分析性能损耗 
  - TLS握手过程
  - 握手后的对称加密报文传输
- 硬件优化
  - 选支持AES-NI特性的CPU
- 软件优化
  - 升级Linux内核
  - 升级OpenSSL
- 会话复用
  - SessionID
  - SessionTicket
  - Pre-shared Key
- 协议优化
  - 密钥交换算法优化 选ECDHE算法
  - TLS升级 升级为TLS1.3
- 证书优化
  - 证书传输优化 选ECDSA证书
  - 证书验证优化 
    - CRL、OCSP、OCSP Stapling


### 分析性能损耗
对HTTPS优化，需要知道哪些步骤性能消耗大
- TLS握手过程
- 握手后的对称加密报文传输

对于第二个环节，主流的对称加密算法AES、ChaCha20性能都不错，而且还有一些CPU厂商针对它做了硬件升级，性能消耗已经算是比较小了

第一个环节，TLS握手过程不只增加了网络延时，而且握手过程中的一些步骤也会性能损耗
- ECDHE算法，握手过程中需要临时生成椭圆曲线公私钥
- 客户端验证证书时，会访问CA获取CRL、OCSP来验证服务器证书是否有效
- 双方计算Pre-Master（对称加密密钥）

### 硬件优化
软件都是跑在硬件上，只要硬件好，软件就快。不过一般HTTPS协议是计算密集型、不是IO密集型，应该升级CPU而不是硬盘、网卡

并且应该选择支持AES-NI特性的CPU，这种CPU能在指令级别优化AES算法，加速数据的加解密传输过程

如果服务器是Linux，可以用 $ sort -u /proc/crypto | grep module | grep aes module : aesni_intel

如果CPU支持AES-NI，那么对称加密算法应该选AES算法或者ChaCha20对称加密算法

### 软件优化
- 软件升级 
  - 将正在使用的软件升级到最新版，比如Linux从2.x升级到4.x，将OpenSSL从1.0.1升级大1.1.1
- 协议优化
  - 对密钥交换过程优化

密钥交换算法优化
- TLS1.2版本使用RSA密钥交换算法，就要4次握手，2RTT才能响应数据，并且不具备前向安全性
- 选用ECDHE算法，三次握手之后就可以响应数据，并且具有前向安全性
  - ECDHE算法给予椭圆曲线实现，不同曲线性能不同，尽量选择x25519曲线，这个曲线是目前最快的椭圆曲线
  - Nginx可以用ssl_ecdh_curve X25519:secp384rl;
  - 对称加密算法如果安全性要求不高，可以使用AES_128_GCM，它比AES——256——GCM快，因为密钥长度短

TLS升级
- 如果可以，将TLS1.2升级到TLS1.3,TLS1.3大幅度优化了握手的步骤，只有1RTT就完成TLS握手，安全性更高
  - TLS1.3是将Hello和公钥交换两个消息合并，减少到只需1RTT完成握手，具体就是客户端在ClientHello消息中带上了支持的椭圆曲线以及对应公钥
  - 而且TLS1.3对密码套件进行缩减，废除了RSA和DH算法，只支持ECDHE
  - 对对称加密和签名算法，只支持目前最安全的几个密码套件
    - 因为以前支持的一些不安全套件，中间人可以利用降级工具，伪造客户端ClientHello消息，替换客户端支持的密码套件，使得消息被破译

### 证书优化
- 证书传输
- 证书验证

证书传输优化
- 便于传输，那肯定是减小证书打小，对应服务器证书采用ECDSA证书而不是RSA证书，相同安全下，ECDSA的密钥长度短很多

证书验证优化
- 验证证书时通过证书链完成，相当复杂。并且这个过程是HTTP访问，有一系列网络开销如DNS查询、建立连接、收发数据等
- CRL：证书吊销列表，这个列表由CA定期更新，其中是一些被撤销的证书序号
  - 由于CA维护的CRL，如果证书刚被吊销，客户端更新CRL前还是信任证书，实时性不好
  - 吊销列表不断增多，列表越来越大，下载速度慢
- OCSP ：在线证书状态协议，查询证书有消息，原理：向CA发查询请求，CA返回证书有效状态
  - OSCP要向CA查询，有网络请求，而且还得看OCSP的服务器怎么样了。
- OCSPStapling
  - 原理： 服务器向CA周期性查询证书状态，获取一个有时间戳和签名的响应结果并缓存
  - 这样在客户端发起请求时，服务器就讲响应结果在TLS握手时发给客户端，有签名的存在导致服务器无法篡改，这样客户端就可以得知证书是否被吊销

### 会话复用
TLS握手的目的就是协商出会话密钥，如果将首次TLS握手协商的对称加密密钥缓存，下次需要HTTPS连接的时候直接使用就会提高性能
两种实现
- SessionID
- SessionTicket

SessionId
- 原理： 客户端和服务端首次TLS握手后，双方在内存中缓存会话密钥，用唯一的SessionID来标识，相当于key-val关系
- 客户端再次连接时，hello带有SessionID，服务器收到后再内存中查找，找到就恢复会话状态。为了安全，内存中的会话密钥定期失效
- 缺点
  - 服务器保存每一个客户端的会话密钥，服务器压力大
  - 负载均衡实现网站服务的话，客户端连接的可能不是上次访问的服务器

SessionTicket
- 原理：服务器不再缓存客户端会话密钥，而是将缓存的工作交给客户端，类似Cookie
  - 客户端与服务器建立连接时，服务器加密会话密钥作为Ticket发给客户端，客户端缓存Ticket
  - 客户端再次连接时，客户端发送Ticket，服务器解密后获取上次的会话密钥，验证有效期，恢复会话
但是对于集群服务器，要确保服务器加密会话密钥的方式一致，这样客户端携带Ticket访问服务器才能确保恢复会话

缺点： 
- SessionID和SessionTicket都不具备前向安全性，一旦加密会话密钥的密钥被破解或泄露，消息会被破解
- 并应对重放攻击很困难
  - 重放攻击： 就是中间人窃听了消息报文，里面有会话密钥，之后复制报文不停发请求
  - 解决：对会话密钥加过期时间

Pre-shared Key
以上两种会话复用方案都要1RTT才能恢复会话，但是TLS1.3只要0RTT就重连，原理和Ticket类似，在重连时，客户端将Ticket和HTTP请求一起发给服务器,这种方式叫 Pre-shared Key。
但是这种方式依然有重放攻击的危险。



### 总结
- 硬件最好选择支持AES-NI的CPU
- 软件最好升级系统，如Linux内核，OpenSSL
- 协议最好采用ECDHE算法
- 证书最好使用ECDSA证书，开启OCSPStapling功能
- 会话重用可以采用Pre-sharedKey技术，但是会话重用技术有重放攻击的风险