## HTTPS ECDHE握手解析

### 离散对数
ECDHE密钥协商算法是DH算法演进的，DH算法是非对称加密算法，可以用于密钥交换，核心思想是离散对数

如果对于整数b和质数p的一个原根a，可以找到唯一的指数i，使得(a^i)%p=b，那么i就称为b的以a为底的模p的离散对数

### DH算法
- 基于离散对数，交换密钥的双方要确定模数和底数作为算法参数，参数公开，用P和G代指
- 然后双方生成随机数作为自己的私钥，私钥严格保管，分别用a和b代称
- 双方通过P、G、私钥。计算出公钥A = （G^a）%P，B=(G^b)%P。A和B公开
- 通过交换公钥，双方都有 P、G、a\b、A、B。之后双方分别执行（B^a）%P 和（A^b）%P,根据离散对数的交换律，这两个值相同，记作H
- 这个值就是对称加密的密钥

在P足够大的情况下，现在的计算机是很难破译a、b私钥的

### DHE算法
DH算法有两种实现：
- static DH 算法，已经废弃
- DHE算法，现在常用

DH算法有一方的私钥匙静态的，也就是说密钥协商的时候，一方的私钥匙一样的。就是客户端公钥才会变化，服务端公钥不变，这样就会到导致服务端私钥被暴力破解，导致泄露

DHE算法每次通信的私钥都是随机生成的、临时的，保证了私钥被破解也不会影响太大

### ECDHE算法
ECDHE 算法在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。

- 双方确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数 公开；
- 双方各自随机生成一个随机数作为私钥d，并与基点 G相乘得到公钥Q（Q = dG），此时公私钥为 Q1 和 d1，另一方的公私钥为 Q2 和 d2；
- 交换各自的公钥，最后一方计算点（x1，y1） = d1Q2，另一方计算点（x2，y2） = d2Q1，由椭圆曲线上可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，
- 因此双方的 x 坐标一样，所以它就是会话密钥

这个过程中，双方私钥都是随机、临时生成的，不公开，即使公开的信息也很难算出椭圆曲线上的离散对数

### ECDHE握手过程
- 第一次握手
  - 客户端发送ClientHello，消息中有TLS版本号、支持的密码套件列表、生成的随机数ClientRandom
- 第二次握手
  - 服务端收到消息响应ServerHello,消息中有服务器确认的TLS版本号和密码套件、给出随机数ServerRandom
  - 这里不同的是采用的密码套件是ECDHE，也就是密钥协商算法使用ECDHE..
  - 服务端再发送Certificate消息，将证书发给客户端
  - 并且在发送证书之后，发送ServerKeyExchange消息，消息包含公钥
    - 选择椭圆曲线和基点，生成随机数作为私钥，按照基点和私钥算出服务端公钥
- TLS第三次握手
  - 客户端收到证书后，验证证书合法性。
  - 客户端生成随机数作为私钥，按照服务端消息生成客户端的椭圆曲线公钥，再用ClientKeyExchange发送给服务端
  - 接下来客户端计算会话密钥，其中使用 客户端随机数+服务端随机数+ECDHE算法的共享密钥生成最终会话密钥
  - 算出来之后，客户端发送ChangeCipperSpec消息，告知服务端后续改用对称算法加密通信
  - 再发送EncryptedHandshakeMessage消息，将之前发送的数据做摘要，用对称密钥加密，让服务端做验证，验证本次对称密钥可用性
- TLS第四次握手
  - 服务端进行同样操作，发送ChangeCipperSpec和EncryptedHandshakeMessage消息，握手完成

### 总结
RSA和ECDHE握手过程的区别：
- RSA不支持前向保密，ECDHE支持前向保密
- RSA在完成四次握手后才能进行数据传输，ECDHE客户端可以不等服务端最后一次TLS握手就提前发送加密的HTTP数据，节约了一个消息往返时间（RTT）
- ECDHE在第二次握手中，会出现服务端发送的ServerKeyExchange消息，RSA握手过程中没有这个消息