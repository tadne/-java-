# TCP连接断开

## TCP四次挥手过程

TCP断开连接使用四次挥手方式

双方都可以主动断开连接，端口连接后主机中的资源将被释放

![alt text](format,png-20230309230614791.webp)

- 客户端打算关闭连接，准备报文
  - 将FIN置于1
  - 客户端进入FIN_WAIT_1状态
- 服务端收到FIN，准备报文
  - 将ACK置于1
  - 服务端进入CLOSE_WAIT状态
- 客户端收到ACK
  - 客户端进入FIN_WAIT_2状态
- 服务端处理完数据后，准备报文
  - 将FIN置于1
  - 服务端进入LAST_ACK状态
- 客户端收到FIN，准备报文
  - 将ACK置于1
  - 客户端进入TIME_WAIT状态
- 客户端经过2MSL时间后，自动关闭
- 服务端经过2MSL时间后，自动关闭

要注意的是，这里服务端连着发了两个报文，这是因为服务端收到要断开连接的消息后，要先处理完数据才能断开

## 为什么要挥手四次？
回顾四次挥手
- 关闭连接时，客户端发送FIN，只表示客户端不再发数据了，但还能收数据
- 服务端收到FIN时，先回ACK，但是服务端可能还有数据要处理和发送，等服务端不再发数据时，才发送FIN给客户端

以上过程可以知道，服务端要等待数据发生和处理，所以服务端ACK和FIN会分开发送，因此要四次挥手。

特定情况下，四次挥手可以变成三次！

## 第一次挥手丢失
客户端调用close函数，向服务端发FIN，客户端进入FIN_WAIT_1

如果第一次挥手丢失，客户端收不到ACK就会超时重传，重传超过默认5次后直接进入close

## 第二次挥手丢失
服务端收到客户端FIN后，回复ACk，服务端进入CLOSE_WAIT状态

ACK报文不会重传，所以客户端收不到ACK，客户端超时重传。重传超过默认5次后直接进入close

如果客户端收到第二次挥手，会等服务端发送FIN，但是对于close函数关闭的连接，无法再发送和接受消息，所以FIN_WAIT_2状态不能持续太久，默认值为60秒。意味着对于close连接，如果60秒没收到FIN，客户端连接直接关闭

但是shutdown函数可以只关闭乙方的发送连接，而不关闭接收。

## 第三次握手丢失
服务端收到客户端的FIN后，内核自动回复ACK，同时连接进入CLOSE_WAIT，表示等待应用进程调用close函数关闭连接。这时内核是没有权利替代进程关闭连接的，必须要进程主动调用close函数触发服务端发送FIN

服务端处于CLOSE_WAIT状态，调用close函数，内核就会发出FIN，同时进入LAST_ACK。等待客户端ACK确认连接关闭。

如果ACK丢失，服务端会超时重传

## 第四次握手丢失
客户端收到服务端第三次挥手FIN后，回复ACK。此时客户端进入TIME_WAIT

Linux中，TIME_WAIT持续2MSL。

如果服务端没有收到ACK，服务端会触发超时重传。如果在2MSL中再次收到FIN，就重发ACK和重置定时器

## 为什么TIME_WAIT等待2MSL
MSL是报文最大生存时间，超过这个时间报文就会被丢弃。因为TCP报文是基于IP协议的，IP头中有TTL字段，是IP数据包可以经过最大的路由数。如果这个值为0则数据丢弃，同时发送ICMP给源主机

MSL和TTL的区别：MSL单位是时间，TTL是经过路由数。**MSL应该大于等于TTL消耗为0的时间**。

**TTL值一般是64，Linux将MSL置为30秒，Linux认为数据报文经过64个路由器时间不会超过30秒，超过就说明报文丢失**，2MSL是指一来一回的双倍时间


## 为什么需要TIME_WAIT状态

主动关闭连接的一方才会有TIME_WAIT状态

原因：
#### 防止历史连接数据被相同四元组连接接收
- 序列号是TCP中标识数据流的一个字节，保证消息的顺序性和可靠性，为每个字节赋予编号。序列号是一个32位无符号数，在到达4G后循环到0
- 初始序列号，TCP连接建立后，客户端服务端会各生成一个序列号保证连接有不同序列号。初始化序列号可以被视为32位计数器，4微秒+1，
- **序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。**

如果TIME_WAIT没有等待时间或时间过短会怎么样？
- 服务端关闭连接前发送SEQ=301，网络延迟
- 服务端重新打开新连接，这时前面的SEQ=301到达客户端，该数据的序列号刚好在客户端接受窗口中，因此客户端会接受这个数据，但这个数据是上一个链接的，导致数据错乱

为了防止历史连接，TCP设计了TIME_WAIT时间持续2MSL。**这个时长足够让两个方向数据包被丢弃**

#### 保证被动关闭连接的一方能被正确关闭

RFC793中指出：TIME-WAIT 作用是**等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。**

如果客户端最后的ACK丢失了，那么服务端会重发FIN。加上客户端没有TIME_WAIT，那就在ACK后直接CLOSE，这时收到服务端重传的FIN会返回RST。为了避免这种情况，客户端必须等待足够长时间保证服务器收到ack。
 
## TIME_WAIT过多的危害
- 占用系统资源，比如文件描述符、内存资源、CPU资源、线程资源
- 占用端口资源，端口优先，一般32768~61000

如果客户端TIME_WAIT过多，占满端口就无法发起连接了。服务端TIME_WAIT过多不会端口占用，因为一个四元组唯一确定一个TCP连接，理论上服务端可以建立很多连接。但是依然有系统资源占用问题。

## 如何优化 TIME_WAIT

- net.ipv4.tcp_tw_reuse 和 tcp_timestamps
  - 让客户端调用连接函数时，随机将TIME_WAIT超过tcp_timestamps秒的连接复用
- net.ipv4.tcp_max_tw_buckets
  - 默认值为18000，系统连接TIME_WAIT的连接超过这么多就会将后面的TIME_WAIT连接状态重置


《UNIX网络编程》：**如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT。**

## 服务器出现大量TIME_WAIT原因

三种情况下可能出现大量TIME_WAIT
- HTTP没有长连接
  - HTTP/1.1后就默认开启长连接，只要服务端或客户端有一方的请求头中有 Connection:close 信息就无法使用。
  - 短连接就是每次发消息都要三次握手四次挥手，并且都是**服务端主动关闭连接**，这时导致出现大量TIME_WAIT

- HTTP长连接超时
  - 长连接只要一方不断开就保持连接。
  - 但是客户端完成HTTP请求后，60秒内没有发起新请求，nginx就会触发回调函数来关闭连接，此时服务器出现TIME_WAIT

- HTTP长连接请求数到上限
  - 服务端有参数定义长连接的最大数，如果超过这个数（nginx中keepalive_requests参数，默认100 ），nginx会主动关闭长连接，出现TIME_WAIT
  - 对于QPS高的场景，这个参数太小会频繁关闭连接导致大量TIME_WAIT

## 服务器出现大量CLOSE_WAIT原因
CLOSE_WAIT是被关闭连接的一方才有的

**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接**

TCP服务端的流程：
- 服务端socket，bind绑定端口、listen监听端口
- 服务端socket注册到epoll
- epoll_wait等连接到来，连接到了就调用accept获取已连接的socket
- 将已连接的socket注册到epoll
- epoll_wait等待事件发生
- 对方连接关闭，我方调用close

原因：
- socket没有注册到epoll，服务端没办法感知到这个，就没办法调用close函数，这是代码逻辑错误，概率小
- 新链接到了没有调用accept，导致客户端断开连接，服务端没机会调用close。这种可能是因为服务端执行accept前代码抛出了异常
- 没有将已连接的socket注册到epoll，导致收到FIN时，服务端无法感知到这个事件。这种可能是因为注册到epoll前代码抛出了异常
- 客户端关闭连接后，服务端没有执行close函数。这种可能是因为代码没写close，或者发生死锁等
  

**当服务器大量CLOSE_WAIT时，通常是代码问题**


## 建立连接，但是客户端故障

故障时指客户端宕机或断电，这种情况如果服务端不发数据给客户端，就无法感知到客户端宕机。这样服务端TCP连接就一直处于ESTABLISH状态，占用系统资源。

为了避免这种情况，TCP有一个保活机制。原理： 定义时间，如果该时间内没有连接活动，就每个一段时间发一个探测报文，如果连续几个报文没有ack就认为当前tcp死亡。

应用程序想使用 TCP 保活机制要通过 socket 接口设置 SO_KEEPALIVE 选项才能生效，没有设置就无法使用 TCP 保活机制。

开启保活机制后要考虑：
- 如果客户端正常工作，探测报文有ack，就刷新保活时间
- 如果客户端宕机并重启，那探测报文可以得到ack，但是消息不是有效消息，产生RST
- 如果客户端宕机，那探测报文就没有ack，多次探测后就报告连接死亡

## 建立连接，但是服务端进程故障

TCP 连接信息由内核维护，当服务端的进程崩溃后，内核要回收进程的所有 TCP 连接资源，内核会发送第一次挥手 FIN 报文，后续的挥手过程也都在内核完成，不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。

使用 kill -9 来模拟进程崩溃的情况，在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手。