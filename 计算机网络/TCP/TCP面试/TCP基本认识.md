# TCP基本认识

### TCP头格式

![TCP 头格式](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)

- 序列号：建立连接时计算机生成的数作初始值，通过SYN包传给接受端，每发一次数据累加一次【数据字节数】的大小。**解决网络包乱序问题**
- 确认应答号：下一次希望收到的数据的序列号，发送端收到后可以确认这个序号前的数据都正常接收。**解决丢包问题**
- 控制位：
  - ACK：该位为1时，确认应答字段变有效，TCP规定除最初建立连接时的SYN外，其他的SYN都是1。
  - RST：该位为1时，表示TCP连接中出现异常必须断开连接
  - SYN：该位为1时，表示希望建立连接，并在序列号字段进行序列化初始值设定
  - FIN：该位为1时，表示希望断开连接，后续没有数据发送。通信要断开连接时，就交换FIN位为1的TCP段

### 为什么要TCP，TCP在哪一层？

![OSI 参考模型与 TCP/IP 的关系](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230419839.png)

IP层是不可靠的，因为不保证网络包的交付、按序交付、以及其中数据的完整性。

如果需要保证网络数据包的可靠性，就要由上层传输层TCP协议负责，因为**TCP在传输层**的**可靠**数据传输服务，能确保接受端接受的网络包是**无损耗、无间隔、非冗余、按序的。


### 什么是TCP？

TCP是**面向连接的、可靠的、基于字节流的**传输层通信协议。

- 面向连接：一对一的，因为一对一才能连接。
- 可靠的：无论网络怎么样，TCP都保证一个报文一定能到达接收端
- 字节流：TCP传输时，消息可能被操作系统分组为多个报文，如果接受方的程序不知道【消息边界】就无法读取消息。并且TCP是**有序**的，前一个报文没到，后面的报文不会传送给应用层处理，同时对重复的报文进行丢弃


### 什么是TCP连接？

**连接** ： 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合、包括Socket、序列号、和窗口大小称为连接

所以可以知道，建立一个TCP连接需要客户端和服务端达成三个信息的共识

- Socket：由IP和端口组成
- 序列号：解决乱序问题
- 窗口大小：做流量控制

### 如何唯一确定一个TCP连接？

TCP四元组可以确定一个唯一TCP连接。

TCP四元组：源IP地址、源端口号、目标IP地址、目标端口号。

其中

- 源IP和目的IP的字段在IP头部，作用：**通过IP协议发送报文给对方主机**
- 源端口和目的端口的字段在TCP头部，作用：**告诉TCP协议将报文发到哪个进程**。

通常来说，服务端是固定的等待服务端请求的，所以**客户端的IP和端口是可变的。**

理论上，最大连接TCP数=客户端IP数*客户端端口数。对于IPv4。客户端IP最多为2^32，客户端端口最大是2^16,也就是TCP连接大概是2^48。但这只是理论上，还是有很多限制

- 文件描述符限制：每个TCP连接都是一个文件，文件描述符占满会发送Too many open files。Linux对可打开的描述符的数量做了限制
  - 系统级：系统可以打开的最大数量
  - 用户级：用户可打开的最大数量
  - 进程级：进程可打开的最大数量
- 内存限制：每个TCP都要占用一定内存，操作系统的内存有限，内存占满OOM。

### UDP和TCP区别，应用场景。

![UDP 头部格式](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png)

UDP不提供复杂机制，用IP提供面向无连接的通信服务。UDP协议简单，头部8字节。

- 目标和源端口：告诉UDP应该将报文发到哪个进程
- 包长度：保存UDP首部的长度和数据长度和
- 校验和：提供可靠UDP首部和数据而设计，防止收到因为网络受损的UDP包

TCP和UDP区别：

- 连接：
  - TCP是面向连接的传输层协议，传输数据要先建立连接
  - UDP不需要连接，即刻传输数据
- 服务对象
  - TCP是一对一服务，一个连接只有两个端点
  - UDP支持一对一、一对多、多对多的交互
- 可靠性
  - TCP是可靠交付数据，数据可以做到无差错、不丢失、不重复、有序。
  - UDP尽力交付，但是不保值可靠交付。但可以基于UDP实现可靠传输，比如QUIC协议。
- 拥塞控制、流量控制
  - TCP有拥塞控制和流量控制机制，保证数据传输的安全性
  - UDP没有，但网络拥堵不会影响UDP效率
- 首部开销
  - TCP首部长，有很大开销，不使用选项只有20字节，使用了可以很大
  - UDP首部只有8字节，并且固定不变
- 传输方式
  - TCP是流式传输，没有边界，但保证顺序和可靠
  - UDP一个包一个包发送，有边界，但会丢包和乱序
- 分片不同
  - TCP数据大于MSS时，就会在传输层分片，目标收到后在传输层组装，如果中途丢包就要重发这个分片包
  - UDP数据大小大于MTU，就会在IP层分片，注解收到后，在IP层组装数据，在传给传输层

TCP和UDP应用场景:

- TCP面向连接，保证数据可靠交付
  - FTP文件传输
  - HTTP/HTTPS
- UDP面向无连接，简单高效
  - 适用于包总量较少通信。DNS、SNMP
  - 视频、音频
  - 广播通信

#### 为什么UDP头部没有头部长度，TCP有？

因为TCP有可变长的选项字段，UDP头部是不变的

#### 为什么UDP头部有包长度，TCP没有？

TCP计算负载数据长度的方式： TCP长度=IP长度-IP首部长度-TCP首部长度

其中IP长度和IP首部长度，在IP首部格式中。TCP首部长度在TCP首部格式中。所以TCP数据长度可以计算得到。

但其实这种说法来说，其实UDP也是IP层的，也可以通过计算得到。

解释：

- 第一种说法：为了网络硬件设计和处理方便，首部长度要是是4字节的整数倍。去掉UDP包长度字节，那就不是4的整数倍
- 第二种说法：现在的UDP是基于IP协议发展的，但当年可能不是这样的。依赖的可能是别的什么协议


### TCP和UDP可以使用同一个端口吗？

**是可以的！！**

- 数据链路层中，MAC地址找局域网主机。
- 网络层：IP地址找主机或路由器
- 传输层：通过端口寻址识别同一计算机的不同应用程序

所以传输层的端口的作用就是区分同一主机中不同应用的数据包，传输层两个协议TCP和UDP在内核中时两个独立模块，主机收到数据包后，可以再IP包头协议号字段找到数据包是TCP/UDP,所以可以按照这个信息确定模块，送给TCP/UDP模块的报文根据端口确定送给哪个应用程序处理。

也就是说，TCP/UDP的端口也独立，TCP是80端口、UDP也可以是80端口不冲突。
