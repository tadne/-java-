SQL优化


insert优化:	插入多条数据时,如果逐条插入,那么频繁的与数据库连接与断开是很耗费资源的

	批量插入:	当然500~1000条数据是批量插入性能比较好的
			如果要插入的数据更多,那就需要分批插入了

		批量插入语法:	insert into 表名 values(字段,..),(字段,..);

	手动提交事务:	避免自动事务提交的频繁开启和关闭

	主键顺序插入:	mysql的主键组织结构的原因...


	如果大批量插入数据:	使用insert性能低,用load指令插入
		#连接服务端,加参数 --local-infile
			mysql --local-infile -u root -p
		#设置全局参数local_infile为1,开启本地加载文件导入数据的开关
			set global local_infile=1
		#执行load指令将数据加载到表中
			load data local infile '文件路径' into table '表名' fields 				terminated by '字段间隔' lines terminated by '行间隔';

	

主键优化:	
	数据组织方式:	innodb表数据根据主键顺序存放,这种表叫做索引组织表
		按照tablespace==>segment==>extent(1m)==>page(16kb)==>row
		表空间,段,区,页,行

		页可以为空,可以填一半,也可以填满
		每一页至少包含2-N行数据(如果一行数据太大,会行溢出),按主键排列
		
		当主键顺序插入时:		第一页满了就插入第二页....

		当主键乱序插入时:		
			页分裂:  如果页都满了,但现在要插入数据
				此时,会开辟新的页,先将要插入页的位置的后的元素移到新页
				将要插入的元素插入到新页后面,新页变道要插入页的后面
				

		当删除一行数据,实际数据并没有被物理删除,只是记录被标记为删除,且其空间可以被声明使用
			页合并:	当页中删除的数据达到页的50%.innodb会开始寻找最近的页(前/后)
				检查是否可以将两个页合并以优化空间使用
			
	主键的设计原则:	
		尽量降低主键的长度
		插入数据时尽量用顺序插入,用自增主键
		尽量不使用UUID做主键或自然主键
		避免对主键的修改
			
order by优化:
	两种排序操作:	
		Using filesort :通过表的索引或全表扫描,读取满足条件的数据行
				在排序缓冲区sort buffer中完成排序操作
				所有不是通过索引直接返回排序结果的排序都叫FileSort
				
		Using index:	通过有序索引顺序扫描直接返回有序数据,即为using index,效率高

	如果是降序排列,mysql可以通过索引倒序扫描,不影响效率

	如果要求字段一个升序一个降序的情况,即使有索引的情况下,后一个字段的索引也会失效
		因为索引默认是升序的,当然,指定后一个字段建立降序索引即可
		
		create index 索引名 on 表名(字段名 desc)

	设计原则:
		尽量优化为using index,效率更高.	(有序且有索引即可)
		根据排序字段建立合适索引,多字段遵循最左前缀法则
		尽量使用覆盖索引
		多字段,有升序有降序时,注意联合索引在创建时的规则
		如果不可避免filesort,大数据排序时,可适当增大排序缓冲区大小(默认256k)
		
	
group by优化:
	设计原则:
		建立适当索引
		尽量使用覆盖索引,遵循最左前缀法则

limit优化:
	优化情况:	当数据量很大,如访问1百万页后数据,会导致耗时很长
			
	优化方案:	覆盖索引+子查询	


count优化:
	MyISAM引擎会将表的总行数存在磁盘中,执行count(*) 时,会直接返回这个数,效率高

	innodb执行count(*)时,一行一行读取计数,效率不高
	
	优化:		自己计数,存到表中

	(innodb)用法:	count(*)	:遍历表,不取值,直接按行累加(mysql底层优化)
			count(主键)	:遍历表,取出所有主键id,返回给服务层,按行累加
			count(1)	:遍历表,不取值,服务层对返回行置1,按行累加
			count(字段)	:若没有notnull,取字段值,返回服务层,判断null,按行累加
					:若有,取字段值,返回服务层,按行累加
		
			其中效率		count(字段)<count(主键)<count(1)<count(*)



update优化:
	当要更改数据的时候,尽量按照索引字段更新数据,不然会导致innodb给表上锁
	如果有索引,那么修改就是行锁

	innodb行锁是根据索引上锁,不是根据记录上锁,并且索引不能失效,否则行锁变表锁

	设计原则:
		建立适当索引
		尽量使用覆盖索引,遵循最左前缀法则


总结:	插入数据:	insert建议批量插入,手动控制事务,主键顺序插入,
			大批量用load data local infile
	主键优化:	主键长度尽量短	建议使用主键自增
	order by优化:	using index:	通过索引返回数据,性能高
			using filesort:	要将返回结果在排序缓冲区排序
	group by优化:	索引,多字段分组遵循最左前缀法则
	limit优化:	覆盖索引+子查询
	count优化:	自己计数		count(字段)<count(主键)<count(1)<count(*)
	updata优化:	根据索引字段更新避免行锁升级表锁	




	
	
	
	
	
	
					