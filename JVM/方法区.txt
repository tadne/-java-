方法区							:用来储存类信息的结构

	所有虚拟机线程共享的区域

	存储了和类的结构相同的信息:  
			成员变量,方法数据,成员方法和构造器方法的代码和一些特殊方法(类构造器)
			以及类信息、常量、静态变量、即时编译器编译后的代码缓存等数据
			运行时常量池

	方法区在虚拟机启动时被创建,其中运行时常量池是在类加载的时候生成的	

		class文件常量池(也叫静态常量池):	
				储存在class文件中的常量值的集合,包含了字面量和符号引用
				主要用于储存字符串常量和基本类型常量值

		运行时常量池:		
				主要存放类加载后被解析的字面量和符号引用
				有动态性,可以添加数据,比如使用String类的intern方法
				
		字符串常量池:
				运行时常量池的一部分,用于储存字符串类型的常量

	
	理论上方法区应该在堆中,但不同虚拟机对此有不同实现.(jdk8后元空间,jdk1.6永久代)

	这里要注意,方法区是JVM的概念,永久代和元空间是方法区的具体实现,可以理解为接口和实现类的关系
		它们不是包含关系

	jdk1.6:	MethodArea 方法区	:永久代	(堆内存)
			常量池:	StringTable字符串常量池(串池)
			Class,	ClassLoader

	jdk1.8:	MethodArea 方法区	:Metaspace 元空间(本地内存)
			Class,ClassLoader,常量池
			(jdk8 StringTable串池转移到堆中)
		
		元空间:	一块用于储存类信息,常量,静态变量等数据的内存区域
				
				主要有方法区,静态变量,即时编译器的代码缓存等数据
				
				线程共享,并且使用的是本地内存,内存大小不受JVM内存大小限制
				
		类的元数据:
				指描述类的信息,包括类的名称,父类,接口,字段,方法等.
				每个类有对应class对象,该对象包含类的元数据信息,元数据信息存在方法区中


	方法区如果内存不够,也会抛出OutOfMemoryError,内存溢出异常

方法区内存溢出
	jdk8前永久代内存溢出
		设置永久代大小:	-XX:MaxPermSize=8m
	jdk8后元空间内存溢出
		例:	创建一个类继承ClassLoader,创建1万个类,导致内存溢出
			ClassWriter cw=new ClassWriter(0);
			//定义类	:	版本号,public,类名,包名,父类,接口
			cw.visit(Opcodes.V1_8,Opcodes.ACC_PUBLIC,ClassName,						PackegName,FutherClassName,interface);
			//二进制字节码文件
			byte[]code=cw.toByteArray;
			//类加载
			test.defineClass("className",code,0,code.length)

为什么使用元空间
	永久代是jvm内存,相对小,效率低
	元空间是系统内存,大小方面更充裕,并且其垃圾回收机制由元空间自行管理,效率更好
		避免了方法区溢出的风险，也方便了垃圾回收器对字符串常量池的管理。


	











